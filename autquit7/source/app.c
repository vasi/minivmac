/*	app.c	Copyright (C) 2007 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*/#include "MYMACAPI.i"#include "COREDEFS.i"#include "POW2UTIL.i"#include "MACENVRN.i"#include "MACINITS.i"#include "SAVEDERR.i"#include "STRUTILS.i"#include "FILEUTIL.i"#include "EXTNSLIB.i"#define IsNormalApp 0 /* for debugging *//*	MFE_ShutDown adapated from MoreFinderEvents,	with the following copyright notice:	MoreFinderEvents 1.0	====================	an AppleEvents package for non-scriptable versions of Finder	by Pete Gontier, Apple Macintosh Developer Technical Support	Copyright (c) 1996 Apple Computer, Inc., All Rights Reserved.	Complaints and kudos to: <gurgle@apple.com>	Thanks to Jon Pugh for 'FinderEvents.p' XCMD and code review	of this package.*/#define kCreatorCode_Finder 'MACS'#define kCreatorCode_AtEase 'mfdr'#define kAEFinderEvents 'FNDR'#define kAEShutDown 'shut'LOCALFUNC tMyErr GetCreatorOfFinderLikeProcess(OSType *processSignature){	tMyErr err;	ProcessInfoRec pir;	ProcessSerialNumber psn = {kNoProcess, kNoProcess};	*processSignature = 0;	pir.processInfoLength = sizeof(ProcessInfoRec);	pir.processName = NULL;	pir.processAppSpec = nil;label_next:	if (noErr == (err = GetNextProcess(&psn)))	if (noErr == (err = GetProcessInformation(&psn, &pir)))	{		if ((pir.processSignature == kCreatorCode_Finder)			|| (pir.processSignature == kCreatorCode_AtEase))		{			*processSignature = pir.processSignature;		} else {			goto label_next;		}	}	return err;}LOCALFUNC tMyErr MFE_ShutDown(void){	tMyErr err;	OSType finderLikeProcess;	AEAddressDesc address;	AppleEvent apple_event;	AppleEvent fReply;	blnr IsOk = falseblnr;	if (noErr ==		(err = GetCreatorOfFinderLikeProcess(&finderLikeProcess)))	{		if (noErr == (err = AECreateDesc(typeApplSignature,			&finderLikeProcess, sizeof(OSType), &address)))		{			if (noErr == (err = AECreateAppleEvent(kAEFinderEvents,				kAEShutDown, &address, kAutoGenerateReturnID,				kAnyTransactionID, &apple_event)))			{				fReply.descriptorType = typeNull;				fReply.dataHandle = nil;				if (noErr == (err = AESend(&apple_event, &fReply,					kAENoReply | kAEAlwaysInteract | kAECanSwitchLayer,					kAENormalPriority, kAEDefaultTimeout, NULL, NULL)))				{					/* ok */				}			}			err = CombineErr(err, AEDisposeDesc(&address));		}	}	return err;}#define MKC_Shift 0x38#define ROMBase 0x02AE#define kDSK_Block_Base 0x00F40000#define kDSK_QuitOnEject 3LOCALPROC DiskOldQuitOnEject(void){	/*		if extension mechanism not present, see if this is old Mini vMac	*/	MyDriverDat_R *SonyVars = (MyDriverDat_R *)get_long(SonyVarsPtr);	if ((SonyVars != NULL)		&& ((1 & (ui5r)SonyVars) == 0)			/* for emulators like sheepshaver */		&& (SonyVars->zeroes[0] == 0)		&& (SonyVars->zeroes[1] == 0)		&& (SonyVars->zeroes[2] == 0)		/* && (SonyVars->zeroes[3] == 0) */		)	{		Ptr StartAddr = *(Ptr *)ROMBase;		if (StartAddr == (Ptr)0x00400000) {			ui5b CheckSum = get_long(StartAddr);			if ((CheckSum == 0x4D1EEEE1)				|| (CheckSum == 0x4D1EEAE1)				|| (CheckSum == 0x4D1F8172))			{				/* this is a Mac Plus, now check for patches */				if ((get_word(StartAddr + 3450) == 0x6022)					&& (get_word(StartAddr + 3752) == 0x4E71)					&& (get_word(StartAddr + 3728) == 0x4E71))				{					/* yes, this is old Mini vMac */					/* so set QuitOnEject the old way */					((short *)kDSK_Block_Base)[kDSK_QuitOnEject] = 1;				}			}		}	}}LOCALPROC DoAutoQuit(void){	tMyErr err;	ui3b theKeys[16];	GetKeys(*(KeyMap *)theKeys);	if ((theKeys[MKC_Shift / 8] & (1 << (MKC_Shift & 7))) == 0) {		/* shift key not pressed */		err = DiskQuitOnEject();		if (kMyErrNoExtn == err) {			DiskOldQuitOnEject();		}	}}LOCALVAR MyDir_R MyDatD;LOCALFUNC tMyErr InitMyApplInfo(void){	tMyErr err;	FCBPBRec pb;	Str255 fileName;	pb.ioCompletion = NULL;	pb.ioNamePtr = fileName;	pb.ioVRefNum = 0;	pb.ioRefNum = CurResFile();	pb.ioFCBIndx = 0;	if (noErr == (err = PBGetFCBInfoSync(&pb))) {		MyDatD.VRefNum = pb.ioFCBVRefNum;		MyDatD.DirId = pb.ioFCBParID;	}	return err;}LOCALVAR blnr GotChildQuit = falseblnr;LOCALVAR ProcessSerialNumber SubAppPsn;LOCALFUNC tMyErr MyResolveAliasNoUIStage0(FSSpec *spec,	blnr *IsAlias){	tMyErr err;	MyDir_R d;	Str255 s;	CInfoPBRec r;	d.VRefNum = spec->vRefNum;	d.DirId = spec->parID;	PStrCopy(s, spec->name);	if (noErr == (err = MyFileGetCatInfo_v2(&d, s, NULL, &r))) {		*IsAlias = (0 != (0x8000 & r.hFileInfo.ioFlFndrInfo.fdFlags));	}	return err;}LOCALFUNC blnr GetAliasFileHandle(FSSpec *spec,	AliasHandle *alias){	Handle h = NULL;	short refNum = HOpenResFile(spec->vRefNum, spec->parID,		spec->name, fsRdPerm);	if (-1 == refNum) {		vCheckSysErr(ResError());	} else {		h = Get1IndResource('alis', 1);		if (NULL != h) {			DetachResource(h);		}		CloseResFile(refNum);	}	*alias = (AliasHandle)h;	return (NULL != h);}LOCALVAR blnr ProgramDone = falseblnr;LOCALFUNC tMyErr GotRequiredParams(const AppleEvent *theAppleEvent){	tMyErr err;	DescType typeCode;	Size actualSize;	/* Make sure there are no additional "required" parameters. */	err = AEGetAttributePtr(theAppleEvent, keyMissedKeywordAttr,		typeWildCard, &typeCode, NULL, 0, &actualSize);	if (errAEDescNotFound == err) {		/* no more required params */		err = noErr;	} else if (noErr == err) {		/* missed required param */		err = errAEEventNotHandled;	} else {		/* other error */	}	return err;}static pascal OSErr DoOpenEvent(const AppleEvent *theAppleEvent,	AppleEvent *reply, long aRefCon){#pragma unused(reply, aRefCon)	tMyErr err;	err = GotRequiredParams(theAppleEvent);	vCheckSysErr(err);	return noErr;}static pascal OSErr DoQuitEvent(const AppleEvent *theAppleEvent,	AppleEvent *reply, long aRefCon){#pragma unused(reply, aRefCon)	tMyErr err;	if (noErr == (err = GotRequiredParams(theAppleEvent))) {		ProgramDone = trueblnr;	}	vCheckSysErr(err);	return noErr;}static pascal OSErr DoApplicationDiedEvent(	const AppleEvent *theAppleEvent, AppleEvent *reply, long aRefCon){	tMyErr err;	DescType typeCode;	ProcessSerialNumber psn;	Size actualSize;	si5b ErrorNumber;	Boolean IsSame;#pragma unused(reply, aRefCon)	if (noErr == (err = AEGetParamPtr(theAppleEvent,		keyErrorNumber, typeLongInteger,		&typeCode, (Ptr)&ErrorNumber,		sizeof(si5b), &actualSize)))	if (noErr == (err = AEGetParamPtr(theAppleEvent,		keyProcessSerialNumber, typeProcessSerialNumber,		&typeCode, (Ptr)&psn,		sizeof(ProcessSerialNumber), &actualSize)))	if (noErr == (err = GotRequiredParams(theAppleEvent)))	if (noErr == (err = SameProcess(&psn,		&SubAppPsn,		&IsSame)))	if (IsSame)	{		GotChildQuit = trueblnr;	}	vCheckSysErr(err);	return noErr;}LOCALFUNC tMyErr MyInstallEventHandler(AEEventClass theAEEventClass,	AEEventID theAEEventID, AEEventHandlerProcPtr p,	long handlerRefcon, blnr isSysHandler){	return AEInstallEventHandler(theAEEventClass,		theAEEventID, p, handlerRefcon, isSysHandler);}LOCALFUNC tMyErr InstallAppleEventHandlers(void){	tMyErr err;	if (noErr == (err = AESetInteractionAllowed(kAEInteractWithLocal)))	if (noErr == (err = MyInstallEventHandler(kCoreEventClass,		kAEOpenApplication, DoOpenEvent, 0, false)))	if (noErr == (err = MyInstallEventHandler(kCoreEventClass,		kAEQuitApplication, DoQuitEvent, 0, false)))	if (noErr == (err = MyInstallEventHandler(kCoreEventClass,		kAEApplicationDied, DoApplicationDiedEvent, 0, false)))	{	}	return err;}/**** event handling *****/LOCALVAR EventRecord curevent;LOCALPROC ProcessHighLevelEvt(void){	AEEventClass thisClass;	thisClass = (AEEventClass)curevent.message;	if (kCoreEventClass == thisClass) {		OSErr err = AEProcessAppleEvent(&curevent);		if (errAEEventNotHandled == err) {			/* ignore */		} else {			vCheckSysErr(err);		}	} else {		vCheckSysErr(errAENotAppleEvent);	}}#if IsNormalAppLOCALVAR WindowPtr MacEventWind;#endif#define appleMenu 1#if IsNormalAppLOCALPROC DecodeSysMenus(long theMenuItem){	short theMenu = HiWord(theMenuItem);	short theItem = LoWord(theMenuItem);	if (appleMenu == theMenu) {		if (1 == theItem) {			ProgramDone = trueblnr;		}	}	HiliteMenu(0);}#endif#if IsNormalAppLOCALPROC inMenuBarAction(void){	DecodeSysMenus(MenuSelect(curevent.where));}#endif#if IsNormalAppLOCALPROC inSysWindowAction(void){	SystemClick(&curevent, MacEventWind);}#endif#if IsNormalAppLOCALPROC ProcessMouseDown(void){	short which_part;	which_part = FindWindow(curevent.where, &MacEventWind);	switch (which_part) {		case inDesk:			/* nothing */			break;		case inMenuBar:			inMenuBarAction();			break;		case inSysWindow:			inSysWindowAction();			break;	}}#endifLOCALPROC ProcessMacEvent(void){	switch (curevent.what) {#if IsNormalApp		case mouseDown:			ProcessMouseDown();			break;#endif		case kHighLevelEvent:			ProcessHighLevelEvt();			break;		default:			/* ignore mouseUp, activateEvt, keyUp, osEvt */			break;	}}LOCALVAR blnr CFExists = falseblnr;LOCALPROC ProgramMain(void){	unsigned long secs;	while (! ProgramDone) {		if (SavedSysErr != noErr) {			/* no way to report errors, so ignore */			SavedSysErr = noErr;		}		if (GotChildQuit) {			GotChildQuit = falseblnr;			vCheckSysErr(MFE_ShutDown());		}		if (WaitNextEvent(everyEvent, &curevent,				CFExists ? 60 : 5 * 60 * 60, NULL))		{			ProcessMacEvent();		}		if (CFExists) {			ReadDateTime(&secs);		}	}	DoAutoQuit();}LOCALFUNC blnr MyResolveFileFromAliasHandle(FSSpec *spec,	AliasHandle alias){	OSErr err;	Boolean needsUpdate;	short aliasCount;	blnr IsOk = falseblnr;	long StartTick = TickCount();label_retry:	aliasCount = 1;	err = MatchAlias(		NULL, kARMSearch | kARMNoUI,		alias, &aliasCount, spec,		&needsUpdate,		NULL,		NULL);	if (nsvErr == err) {		if (TickCount() - StartTick < 900) {			if (WaitNextEvent(everyEvent, &curevent,					15, NULL))			{				ProcessMacEvent();			}			goto label_retry;		}	}	if (CheckSysErr(err))	if (aliasCount > 0)	{		IsOk = trueblnr;	}	return IsOk;}LOCALFUNC blnr MyResolveAliasNoUI(FSSpec *spec){	blnr IsAlias;	blnr IsOk;	int RetryCount = 8;label_retry:	IsOk = falseblnr;	if (--RetryCount >= 0)	if (CheckSysErr(MyResolveAliasNoUIStage0(spec, &IsAlias)))	{		if (! IsAlias) {			/* ok as is */			IsOk = trueblnr;		} else {			AliasHandle alias;			if (GetAliasFileHandle(spec, &alias)) {				if (MyResolveFileFromAliasHandle(spec, alias)) {					IsOk = trueblnr;				}				DisposeHandle((Handle)alias);				if (IsOk) {					goto label_retry;				}			}		}	}	return IsOk;}typedef AppParameters **AppParametersHandle;/*buildlaunchparamlist adapted from appletprocess.cin macBird, with the following copyright notice:Copyright (c) 1991-2000 UserLand Software, Inc.Permission is hereby granted, free of charge, to any person obtaining acopy of this software and associated documentation files (the"Software"), to deal in the Software without restriction, includingwithout limitation the rights to use, copy, modify, merge, publish,distribute, sublicense, and/or sell copies of the Software, and topermit persons to whom the Software is furnished to do so, subject tothe following conditions:The above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESSOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OFMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE ANDNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BELIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTIONOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTIONWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.*/LOCALFUNC blnr buildlaunchparamlist (FSSpec *fsdoc,	AppParametersHandle *appparams){	AEDesc addrdesc;	AEDesc launchdesc;	AEDescList doclist;	AppleEvent event;	AliasHandle halias;	AEDesc docdesc;	blnr IsOk = falseblnr;	if (CheckSysErr(NewAliasMinimal(fsdoc, &halias))) {		docdesc.descriptorType = typeAlias;		docdesc.dataHandle = (Handle)halias;		if (CheckSysErr(AECreateList(nil, 0, false, &doclist))) {			if (CheckSysErr(AEPutDesc(&doclist, 0, &docdesc))) {				addrdesc.descriptorType = typeNull;				addrdesc.dataHandle = nil;				if (CheckSysErr(AECreateAppleEvent(					kCoreEventClass, kAEOpenDocuments, &addrdesc,					kAutoGenerateReturnID, kAnyTransactionID, &event)))				{					if (CheckSysErr(AEPutParamDesc(&event,						keyDirectObject, &doclist)))					{						if (CheckSysErr(AECoerceDesc(&event,							typeAppParameters, &launchdesc)))						{							*appparams = (AppParametersHandle)								launchdesc.dataHandle;							IsOk = trueblnr;						}					}					vCheckSysErr(AEDisposeDesc(&event));				}			}			vCheckSysErr(AEDisposeDesc(&doclist));		}		vCheckSysErr(AEDisposeDesc(&docdesc));	}	return IsOk;}LOCALFUNC blnr LaunchTheSubApp(void){	LaunchParamBlockRec r;	FSSpec theSpec;	FSSpec docSpec;	AppParametersHandle docparams = nil;	blnr IsOk = falseblnr;	theSpec.vRefNum = MyDatD.VRefNum;	theSpec.parID = MyDatD.DirId;	PStrFromCStr(theSpec.name, "app");	if (MyResolveAliasNoUI(&theSpec)) {		r.reserved1 = 0;		r.reserved2 = 0;		r.launchBlockID = extendedBlock;		r.launchEPBLength = extendedBlockLen;		r.launchFileFlags = 0;		r.launchControlFlags = launchContinue			| launchNoFileFlags;		r.launchAppSpec = &theSpec;		r.launchAppParameters = NULL;		docSpec.vRefNum = MyDatD.VRefNum;		docSpec.parID = MyDatD.DirId;		PStrFromCStr(docSpec.name, "doc");		if (MyResolveAliasNoUI(&docSpec)) {			if (buildlaunchparamlist(&docSpec, &docparams)) {				HLock ((Handle) docparams);				r.launchAppParameters = *docparams;			}		}		if (CheckSysErr(LaunchApplication((LaunchPBPtr)&r))) {			SubAppPsn = r.launchProcessSN;			IsOk = trueblnr;		}		if (NULL != docparams) {			DisposeHandle((Handle) docparams);		}	}	return IsOk;}LOCALPROC ProgramZapVars(void){}#if IsNormalAppLOCALPROC MyMenusInit(void){#define chrApple ((unsigned char)20)	Str255 s;	MenuHandle myMenu;	PStrFromChar(s, chrApple);	myMenu = NewMenu(appleMenu, s);	if (myMenu != NULL) {		PStrFromCStr(s, "Quit/Q");		AppendMenu(myMenu, s);		InsertMenu(myMenu, 0);	}	DrawMenuBar();}#endifLOCALPROC ProgramPreInit(void){#if ! IsNormalApp	/* work around bug, see TN1070 */	THz myZone = GetZone();	if (myZone->bkLim != LMGetHeapEnd()) {		LMSetHeapEnd(myZone->bkLim);	}#endif#if ShouldUnloadDataInit	MyUnloadDataInit();#endif	/* MaxApplZone(); */	InitGraf((Ptr) &qd.thePort);#if IsNormalApp	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();	MyMenusInit();#endif}LOCALFUNC blnr ProgramInit(void){	if (HaveWaitNextEventAvail())	if (HaveAppleEvtMgrAvail())	if (CheckSysErr(InitMyApplInfo()))	{		(void) CheckSysErr(InstallAppleEventHandlers());		if (! LaunchTheSubApp()) {			SavedSysErr = noErr; /* ignore errors */		}		CFExists = CheckSysErr(MyFileExists_v2(&MyDatD,			(StringPtr)"\pcf", &CFExists))			&& CFExists;		return trueblnr;	}	return falseblnr;}LOCALPROC ProgramUnInit(void){}int main(void){	ProgramZapVars();	ProgramPreInit();	if (ProgramInit()) {		ProgramMain();	}	ProgramUnInit();	return 0;}