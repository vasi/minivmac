/*	APPLMAIN.c	Copyright (C) 2007 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	APPLication MAIN*//*	Distantly descends from source found in unzip-5.52,	which with some modifications by Dirk Haase, descends	from code with this notice:	MacBinaryIII.c	Copyright  1997 Christopher Evans (cevans@poppybank.com)	Basic encoding and decoding of Macintosh files to the	MacBinary III spec.	This file is part of the MacBinaryIII_src_C.sit package*//*	That code seemed a bit buggy, also looked at	"Mac Binary Converter", put on	SourceForge by boga (Mikl?s Fazekas)	under MIT License, at	http://sourceforge.net/projects/macbinconv*//* 100 bytes at offset 1 */struct MacBin_R {	Str63 FileName;	FInfo FlFndrInfo;	ui3b protected;	ui3b VersionOneCheckZero;	long FlLgLen;	long FlRLgLen;	unsigned long FlCrDat;	unsigned long FlMdDat;	si4b GetInfoCommentLength;};typedef struct MacBin_R MacBin_R;/* 24 bytes at offset 102 */struct MacBin3_R {	OSType MacbinarySig;	char FilenameScript;	si3b kExtendedFinderFlags;	ui5b reserved[2];	ui5b TotalFileLength;	ui4b SecondaryHeaderLength;	ui3b CurrentVersion;	ui3b MinimumVersionOffset;	ui4b CRC;};typedef struct MacBin3_R MacBin3_R;LOCALVAR const ui4b crc_table[256] = {	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,	0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,	0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,	0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,	0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,	0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,	0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,	0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,	0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,	0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,	0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,	0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,	0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,	0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,	0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,	0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,	0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,	0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,	0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,	0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,	0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,	0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,	0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,	0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,	0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,	0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,	0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,	0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,	0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,	0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,	0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,	0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0};LOCALFUNC ui4b crc16(ui4b seed, ui3b *p, uimr n){	simr i;	ui4b hold = seed;	for (i = n; --i >= 0; ) {		hold = (hold << 8) ^ crc_table[((*p++) ^ (hold >> 8)) & 0x00FF];	}	return hold;}#if 0LOCALFUNC OSErr SetDesktopComment(MyDir_R *d, StringPtr s,	char *comment, long length){	DTPBRec pb;	OSErr err;	pb.ioCompletion = nil;	pb.ioNamePtr = NULL;	pb.ioVRefNum = d->VRefNum;	err = PBDTGetPath(&pb);	if (err == noErr) {		pb.ioNamePtr    = s;		pb.ioDTBuffer   = comment;		pb.ioDirID      = d->DirId;		pb.ioDTReqCount = length;		err = PBDTSetComment(&pb, false);	}	return err;}#endifLOCALFUNC blnr BytesAllZero(ui3b *p, uimr n){	simr i = n;	for (i = n; --i >= 0; ) {		if (0 != *p++) {			return falseblnr;		}	}	return trueblnr;}LOCALFUNC tMyErr DoFilter1(short src_refNum){	tMyErr err;	uimr maxDataLen;	ui3b MBOldVersion;	MacBin_R mbh;	ui3b MBFinderFlagsLow;	MacBin3_R mb3h;	ui4b ComputerOS;	ui4b crc;	uimr rfOffset;	uimr DataForkOffset;	uimr ResourceOffset;	uimr GetInfoCommentOffset;	MyDir_R dst_d;	Str255 dst_s;	short dfRefNum;	short rfRefNum;	HParamBlockRec pb;	if (noErr == (err = MyOpenFileGetEOF_v2(src_refNum, &maxDataLen)))	if (noErr == (err = MyReadBytes_v2(src_refNum, (MyPtr)&MBOldVersion, 1)))	if (noErr == (err = MyReadBytes_v2(src_refNum, (MyPtr)&mbh, sizeof(MacBin_R))))	if (noErr == (err = MyReadBytes_v2(src_refNum, (MyPtr)&MBFinderFlagsLow, 1)))	if (noErr == (err = MyReadBytes_v2(src_refNum, (MyPtr)&mb3h, sizeof(MacBin3_R))))	if (noErr == (err = MyReadBytes_v2(src_refNum, (MyPtr)&ComputerOS, 2)))	{		/* ok */	}	if (noErr != err) {		return err;	}	if ((0 == MBOldVersion)		&& (mbh.FileName[0] >= 1)		&& (mbh.FileName[0] < 64)		&& (0 == (mbh.FlFndrInfo.fdFlags & 0x00FF))		&& (0 == mbh.VersionOneCheckZero)		&& (mbh.FlLgLen >= 0)		&& (mbh.FlRLgLen >= 0)		&& (0 == ComputerOS))	{		if ((0 == MBFinderFlagsLow)			&& BytesAllZero((ui3b *)&mb3h, sizeof(MacBin3_R)))		{			/* MyAlertFromCStr("version 128"); */		} else {			crc = crc16(0, (ui3b *)&MBOldVersion, 1);			crc = crc16(crc, (ui3b *)&mbh, sizeof(MacBin_R));			crc = crc16(crc, (ui3b *)&MBFinderFlagsLow, 1);			crc = crc16(crc, (ui3b *)&mb3h, 22);			if (mb3h.CRC != crc) {				MyAlertFromCStr("The header checksum is wrong."); /*^*/				err = kMyErrReported;			} else {				/* just for information, we don't care: */#if 0				if (mb3h.MacbinarySig == 'mBIN') {					MyAlertFromCStr("version 130");				} else {					MyAlertFromCStr("version 129");				}#endif			}		}	} else {		MyAlertFromCStr("This does not seem to be a MacBinary file.");		err = kMyErrReported;	}	if (noErr != err) {		return err;	}	rfOffset = 128;	if (mb3h.SecondaryHeaderLength) {		rfOffset += mb3h.SecondaryHeaderLength;		rfOffset = CeilPow2Mult(rfOffset, 7);	}	DataForkOffset = rfOffset;	rfOffset += mbh.FlLgLen;	rfOffset = CeilPow2Mult(rfOffset, 7);	ResourceOffset = rfOffset;	rfOffset += mbh.FlRLgLen;	rfOffset = CeilPow2Mult(rfOffset, 7);	GetInfoCommentOffset = rfOffset;	rfOffset += mbh.GetInfoCommentLength;	if (rfOffset > maxDataLen) {		MyAlertFromCStr("This file is shorter than expected.");		return kMyErrReported;	}	(void) ProgressBar_SetStage_v2("Select destination\311", 0);	UpdateProgressBar();	if (noErr == (err = MyFilePutNew_v2((StringPtr)"\pOutput File",		mbh.FileName, &dst_d, dst_s)))	if (noErr == (err = MyCreateFileOverWrite_v2(&dst_d, dst_s)))	if (noErr == (err = ProgressBar_SetStage_v2("Copying file data",		mbh.FlLgLen + mbh.FlRLgLen)))	{		if ((0 != mbh.FlLgLen) && (noErr == err)) {			if (noErr == (err = MyFileOpenWrite_v2(&dst_d, dst_s, &dfRefNum))) {				if (noErr == (err = MyOpenFileSetFPos(src_refNum, DataForkOffset)))				if (noErr == (err = MyOpenFileSetEOF_v2(dfRefNum, mbh.FlLgLen)))				if (noErr == (err = MyFileCopyBytes_v2(src_refNum, dfRefNum, mbh.FlLgLen)))				{					/* ok */				}				err = CombineErr(err, MyOpenFileUpdtLocation_v3(dfRefNum, &dst_d, dst_s,					&dst_d, dst_s));				err = CombineErr(err, MyCloseFile_v2(dfRefNum));			}		}		if ((0 != mbh.FlRLgLen) && (noErr == err)) {			if (noErr == (err = MyFileOpenRFWrite_v2(&dst_d, dst_s, &rfRefNum))) {				if (noErr == (err = MyOpenFileSetFPos(src_refNum, ResourceOffset)))				if (noErr == (err = MyOpenFileSetEOF_v2(rfRefNum, mbh.FlRLgLen)))				if (noErr == (err = MyFileCopyBytes_v2(src_refNum, rfRefNum, mbh.FlRLgLen)))				{					/* ok */				}				err = CombineErr(err, MyOpenFileUpdtLocation_v3(rfRefNum, &dst_d, dst_s,					&dst_d, dst_s));				err = CombineErr(err, MyCloseFile_v2(rfRefNum));			}		}		if (noErr == err) {			if (noErr == (err = MyFileGetInfo_v2(&dst_d, dst_s, &pb))) {				pb.fileParam.ioFlFndrInfo.fdType    = mbh.FlFndrInfo.fdType;				pb.fileParam.ioFlFndrInfo.fdCreator = mbh.FlFndrInfo.fdCreator;				pb.fileParam.ioFlFndrInfo.fdFlags =					(0xF87E & (mbh.FlFndrInfo.fdFlags						| MBFinderFlagsLow))					| (pb.fileParam.ioFlFndrInfo.fdFlags & ~ 0xF87E);				pb.fileParam.ioFlFndrInfo.fdFlags &= 0xFEFF;					/* clear initted bit */#if 0 /* put it where user says, not where file says */				pb.fileParam.ioFlFndrInfo.fdLocation = mbh.FlFndrInfo.fdLocation;#endif#if 0 /* fdFldr doesn't make sense on a different system than original */				pb.fileParam.ioFlFndrInfo.fdFldr = mbh.FlFndrInfo.fdFldr;#endif				pb.fileParam.ioFlCrDat =					mbh.FlCrDat;				pb.fileParam.ioFlMdDat =					mbh.FlMdDat;#if 0 /* reserved, don't seem to be used until os x */				/* pb.hfileInfo.ioFlXFndrInfo.fdXFlags */				((si3b *)(&pb.hfileInfo.ioFlXFndrInfo.fdUnused[3]))[1]					=					mb3h.kExtendedFinderFlags;#endif#if 0 /* inside mac says treat as reserved */				/* pb.hfileInfo.ioFlXFndrInfo.fdScript */				((si3b *)(&pb.hfileInfo.ioFlXFndrInfo.fdUnused[3]))[0]					=					mb3h.FilenameScript;#endif				err = MyFileSetInfo_v2(&dst_d, dst_s, &pb);			}		}#if 0		if ((0 != mbh.GetInfoCommentLength) && (noErr == err)) {			char comment[256];			if (noErr == (err = MyBackReadBytes_v2(src_refNum, GetInfoCommentOffset,				(MyPtr)comment, mbh.GetInfoCommentLength)))			{				SetDesktopComment(&dst_d, dst_s, comment, mbh.GetInfoCommentLength);			}		}#endif		if (noErr != err) {			(void) MyDeleteFile_v2(&dst_d, dst_s);				/* ignore any error, since already got one */		}	}	return err;}LOCALFUNC tMyErr DoFilter2(void){	tMyErr err;	MyDir_R src_d;	Str255 src_s;	short src_refNum;	blnr IsOk = falseblnr;	GetInputFile(&src_d, src_s);	if (noErr == (err = MyOpenOldFileRead_v2(&src_d, src_s,		&src_refNum)))	{		err = DoFilter1(src_refNum);		err = CombineErr(err, MyCloseFile_v2(src_refNum));	}	return err;}LOCALPROC ProgramMain(void){	vCheckSysErr(ProgressBar_SetStage_v2("Ready for a MacBinary file\311", 0));label_1:	WaitForInput();	if (GotInputCur) {		if (! CheckSysErr(DoFilter2())) {			ClearInputA();			vCheckSysErr(ProgressBar_SetStage_v2("Aborted, ready for another file\311", 0));		} else {			vCheckSysErr(ProgressBar_SetStage_v2("Done, ready for another file\311", 0));		}		CloseInputCur();		goto label_1;	}}LOCALPROC ProgramZapVars(void){}LOCALPROC ProgramPreInit(void){	OneWindAppPreInit();}LOCALFUNC blnr ProgramInit(void){	if (CheckSysErr(MyMemory_Init_v2()))	if (CheckSysErr(OneWindAppInit_v2()))	{		return trueblnr;	}	return falseblnr;}LOCALPROC ProgramUnInit(void){	OneWindAppUnInit();	MyMemory_UnInit();}int main(void){	ProgramZapVars();	ProgramPreInit();	if (ProgramInit()) {		ProgramMain();	}	ProgramUnInit();	return 0;}