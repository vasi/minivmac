/*	APPLMAIN.c	Copyright (C) 2007 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	APPLication MAIN*/LOCALVAR blnr CapturingInserts = falseblnr;LOCALVAR ui5b SaveCallBack;LOCALVAR ui4b SaveRawMode;LOCALPROC CapturingInsertsOn(void){	tMyErr err;	if (! CapturingInserts) {		if  (noErr == (err = DiskGetCallBack_v2(&SaveCallBack))) {			if  (noErr == (err = DiskSetCallBack_v2(0))) {				if  (noErr == (err = DiskGetRawMode_v2(&SaveRawMode))) {					if  (noErr == (err = DiskSetRawMode_v2(1))) {						CapturingInserts = trueblnr;					}					if (noErr != err) {						(void) DiskSetRawMode_v2(SaveRawMode);							/* ignore any error, since already got one */					}				}			}			if (noErr != err) {				(void) DiskSetCallBack_v2(SaveCallBack);					/* ignore any error, since already got one */			}		}		(void) CheckSysErr(err);	}}LOCALPROC CapturingInsertsOff(void){	tMyErr err;	if (CapturingInserts) {		err = DiskSetRawMode_v2(SaveRawMode);		err = CombineErr(err, DiskSetCallBack_v2(SaveCallBack));		(void) CheckSysErr(err);		CapturingInserts = falseblnr;	}}LOCALFUNC blnr TryCaptureInsert(tDrive *r){	OSErr err = DiskNextPendingInsert(r);	blnr v = falseblnr;	if (noErr == err) {		v = trueblnr;	} else if (err == (OSErr)0xFFC8) {		/* nothing yet */	} else {		vCheckSysErr(err);	}	return v;}/*	HostVolInsertNew_v2 doesn't work properly	if there are already pending inserts. So	try to clear out all pending inserts before	begin processing first one.*/#define MyInsQLg2Sz 4#define MyInsQSz (1 << MyInsQLg2Sz)#define MyInsQIMask (MyInsQSz - 1)LOCALVAR tDrive MyInsQA[MyInsQSz];LOCALVAR ui4r MyInsQIn = 0;LOCALVAR ui4r MyInsQOut = 0;LOCALFUNC blnr TryCaptureInsert_buffered(tDrive *r){	tDrive r0;	blnr IsOk = falseblnr;Label_1:	if (MyInsQIn - MyInsQOut <= MyInsQSz) {		if (TryCaptureInsert(&r0)) {			MyInsQA[MyInsQIn & MyInsQIMask] = r0;			++MyInsQIn;			goto Label_1;		}	}	if (MyInsQIn != MyInsQOut) {		*r = MyInsQA[MyInsQOut & MyInsQIMask];		++MyInsQOut;		IsOk = trueblnr;	}	return IsOk;}LOCALPROC ClearInsertBuffer(void){	tDrive r;	while (MyInsQIn != MyInsQOut) {		r = MyInsQA[MyInsQOut & MyInsQIMask];		++MyInsQOut;		(void) DiskEject_v2(r);	}}LOCALVAR blnr ReadyToImport = falseblnr;LOCALPROC CheckStateAfterEvents(void){	if (ReadyToImport != (! gBackgroundFlag)) {		ReadyToImport = ! ReadyToImport;		if (ReadyToImport) {			(void) CheckSysErr(ProgressBar_SetStage_v2("Ready to convert\311", 0));			CapturingInsertsOn();		} else {			CapturingInsertsOff();			(void) CheckSysErr(ProgressBar_SetStage_v2("", 0));		}	}}#define checkheaderoffset 0#define checkheadersize 128#define kDC42offset_diskName      0#define kDC42offset_dataSize     64#define kDC42offset_tagSize      68#define kDC42offset_dataChecksum 72#define kDC42offset_tagChecksum  76#define kDC42offset_diskFormat   80#define kDC42offset_formatByte   81#define kDC42offset_private      82#define kDC42offset_userData     84#define do_get_mem_byte(a) ((ui3r)*((ui3b *)(a)))#define do_get_mem_word(a) ((ui4r)*((ui4b *)(a)))#define do_get_mem_long(a) ((ui5r)*((ui5b *)(a)))LOCALFUNC tMyErr CheckIsDC42Format(tDrive InsertInVol, ui5r L,	ui5r *DataOffset, ui5r *DataSize){	tMyErr err;	blnr FormatOk;	ui3b Temp[checkheadersize];	ui5r DataOffset0;	ui5r DataSize0;	ui5r TagOffset0;	ui5r TagSize0;	ui5r n = checkheadersize;	if (noErr == (err = DiskRead_v2(Temp, InsertInVol, checkheaderoffset, &n))) {		FormatOk = falseblnr;		/* format check below copied from Mini vMac */		if (0x0100 == do_get_mem_word(&Temp[kDC42offset_private])) {			/* DC42 signature found, check sizes */			DataSize0 = do_get_mem_long(&Temp[kDC42offset_dataSize]);			TagSize0 = do_get_mem_long(&Temp[kDC42offset_tagSize]);			DataOffset0 = kDC42offset_userData;			TagOffset0 = DataOffset0 + DataSize0;			if (L >= (TagOffset0 + TagSize0))			if (0 == (DataSize0 & 0x01FF))			if ((DataSize0 >> 9) >= 4)			if (Temp[kDC42offset_diskName] < 64) /* length of pascal string */			{				*DataOffset = DataOffset0;				*DataSize = DataSize0;				FormatOk = trueblnr;			}		}		if ((! FormatOk) && (noErr == err)) {			MyAlertFromCStr("I don't think that is a Disk Copy 4.2 disk image.");			err = kMyErrReported;		}	}	return err;}LOCALPROC TryConvertHostFile(void){	tMyErr err;	tDrive InsertInVol;	MyPStr s;	ui5b L;	ui4r Name;	tDrive InsertOutVol;	ui5r DataOffset;	ui5r DataSize;	if (TryCaptureInsert_buffered(&InsertInVol)) {		if (noErr == (err = DiskGetName2Pstr_v2(InsertInVol, s)))		if (noErr == (err = DiskGetSize_v2(InsertInVol, &L)))		if (noErr == (err = CheckIsDC42Format(InsertInVol, L, &DataOffset, &DataSize)))		if (noErr == (err = ProgressBar_SetStage_v2(			"Making the new file\311", 0)))		{			if (noErr == (err = PStr2Pbuf_v2(s, &Name)))			if (noErr == (err = HostVolInsertNew_v2(L, Name, &InsertOutVol)))			{				if (noErr == (err = ProgressBar_SetStage_v2("Running, type command-period to abort\311", L)))				if (noErr == (err = WriteFromVolToVol(InsertInVol, DataOffset, InsertOutVol, 0, DataSize)))				{				}				err = NewDiskEject_v2(InsertOutVol, err);			}		}		err = CombineErr(err, DiskEject_v2(InsertInVol));		err = CombineErr(err, ProgressBar_SetStage_v2((noErr == err)			? "Done, ready to convert another\311"				: "Aborted, ready to convert another\311",			0));		if (kMyErrUsrCancel != err) {			(void) CheckSysErr(err);		}	}}LOCALPROC ProgramMain(void){	while (! ProgramDone) {		UpdateProgressBar();		ReportErrors();		MyDoNextEvents(CapturingInserts ? 5			: 5 * 60 * 60);		CheckStateAfterEvents();		if (CapturingInserts) {			TryConvertHostFile();		}	}}LOCALPROC ProgramZapVars(void){}LOCALPROC ProgramPreInit(void){	OneWindAppPreInit();}LOCALFUNC blnr ImportExtnInit(void){	ui4r version;	ui5b features;	blnr IsOk = falseblnr;	if (! (noErr == HaveDiskExtenstion_v2())) {		MyAlertFromCStr("The Mini vMac extension mechanism is not available.");	} else if (! CheckSysErr(DiskVersion_v2(&version))) {	} else if (version < 2) {		MyAlertFromCStr("The Disk Extension version is too old.");	} else if (! CheckSysErr(DiskFeatures_v2(&features))) {	} else if (0 == (features & ((ui5b)1 << kFeatureCmndDisk_New))) {		MyAlertFromCStr("The new file creation feature is not available.");	} else if (0 == (features & ((ui5b)1 << kFeatureCmndDisk_RawMode))) {		MyAlertFromCStr("Raw mode access feature is not available.");	} else if (0 == (features & ((ui5b)1 << kFeatureCmndDisk_GetName))) {		MyAlertFromCStr("Get Disk name feature is not available.");	} else {		IsOk = trueblnr;	}	return IsOk;}LOCALFUNC blnr ProgramInit(void){	if (CheckSysErr(MyMemory_Init_v2()))	if (ImportExtnInit())	if (CheckSysErr(OneWindAppInit_v2()))	{		return trueblnr;	}	return falseblnr;}LOCALPROC ProgramUnInit(void){	CapturingInsertsOff();	ClearInsertBuffer();	OneWindAppUnInit();	MyMemory_UnInit();}int main(void){	ProgramZapVars();	ProgramPreInit();	if (ProgramInit()) {		ProgramMain();	}	ProgramUnInit();	return 0;}