/*	APPLMAIN.c	Copyright (C) 2007 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	APPLication MAIN*/LOCALVAR blnr CapturingInserts = falseblnr;LOCALVAR ui5b SaveCallBack;LOCALVAR ui4b SaveRawMode;LOCALPROC CapturingInsertsOn(void){	tMyErr err;	if (! CapturingInserts) {		if  (noErr == (err = DiskGetCallBack_v2(&SaveCallBack))) {			if  (noErr == (err = DiskSetCallBack_v2(0))) {				if  (noErr == (err = DiskGetRawMode_v2(&SaveRawMode)))				{					if  (noErr == (err = DiskSetRawMode_v2(1))) {						CapturingInserts = trueblnr;					}					if (noErr != err) {						(void) DiskSetRawMode_v2(SaveRawMode);						/* ignore any error, since already got one */					}				}			}			if (noErr != err) {				(void) DiskSetCallBack_v2(SaveCallBack);					/* ignore any error, since already got one */			}		}		(void) CheckSysErr(err);	}}LOCALPROC CapturingInsertsOff(void){	tMyErr err;	if (CapturingInserts) {		err = DiskSetRawMode_v2(SaveRawMode);		err = CombineErr(err, DiskSetCallBack_v2(SaveCallBack));		(void) CheckSysErr(err);		CapturingInserts = falseblnr;	}}LOCALFUNC blnr TryCaptureInsert(tDrive *r){	OSErr err = DiskNextPendingInsert(r);	blnr v = falseblnr;	if (noErr == err) {		v = trueblnr;	} else if (err == (OSErr)0xFFC8) {		/* nothing yet */	} else {		vCheckSysErr(err);	}	return v;}LOCALVAR blnr ReadyToImport = falseblnr;LOCALPROC CheckStateAfterEvents(void){	if (ReadyToImport != (! gBackgroundFlag)) {		ReadyToImport = ! ReadyToImport;		if (ReadyToImport) {			(void) CheckSysErr(ProgressBar_SetStage_v2(				"Ready to check\311", 0));			CapturingInsertsOn();		} else {			CapturingInsertsOff();			(void) CheckSysErr(ProgressBar_SetStage_v2("", 0));		}	}}#define do_get_mem_byte(a) ((ui3r)*((ui3b *)(a)))#define do_get_mem_word(a) ((ui4r)*((ui4b *)(a)))#define do_get_mem_long(a) ((ui5r)*((ui5b *)(a)))LOCALPROC DC42UpdateBlockChecksum(ui3b *p, ui5r n, ui5r *r){	ui5b sum = *r;	while (0 != n) {		--n;		/* ROR.l sum+word */		sum += do_get_mem_word(p);		p += 2;		sum = (sum >> 1) | ((sum & 1) << 31);	}	*r = sum;}LOCALFUNC tMyErr DC42BlockChecksumUsingBuff(tDrive Drive_No,	ui5r Sony_Start, ui5r Sony_Count, ui5r *r,	void *buff, ui5r BuffL){	tMyErr err;	ui5r sum = 0;	ui5r L = Sony_Count;	ui5r offset = Sony_Start;Label_1:	if (L == 0) {		*r = sum;		err = noErr;	} else {		ui5r n = (L > BuffL) ? BuffL : L;		if (noErr == (err = CheckAbortRequested()))		if (noErr == DiskRead_v2(buff, Drive_No, offset, &n))		{			L -= n;			offset += n;			ProgressBarVal += n;			/* add to Checksum */			DC42UpdateBlockChecksum(buff,				n >> 1, /* number of words */				&sum);			goto Label_1;		}	}	return err;}LOCALFUNC tMyErr DC42BlockChecksum(tDrive Drive_No,	ui5r Sony_Start, ui5r Sony_Count, ui5r *r){	tMyErr err;	MyPtr p;	if (noErr == (err = TempBuffHBeginUse_v2(&p))) {		err = DC42BlockChecksumUsingBuff(Drive_No,			Sony_Start, Sony_Count, r, p, TempBuffSize);		TempBuffHEndUse();	}	return err;}#define checkheaderoffset 0#define checkheadersize 128#define kDC42offset_diskName      0#define kDC42offset_dataSize     64#define kDC42offset_tagSize      68#define kDC42offset_dataChecksum 72#define kDC42offset_tagChecksum  76#define kDC42offset_diskFormat   80#define kDC42offset_formatByte   81#define kDC42offset_private      82#define kDC42offset_userData     84LOCALPROC UpdtProgressAlertFromCStr(char *s){	UpdateProgressBar(); /* before modal dialog */	MyAlertFromCStr(s);}LOCALFUNC tMyErr CheckIsDC42Format(tDrive InsertInVol, ui5r L){	/*		returns noErr if can perform check, not if valid image	*/	tMyErr err = noErr;	blnr FormatOk = falseblnr;	if (L < (checkheaderoffset + checkheadersize)) {		MyAlertFromCStr(			"The image is too small to contain a Disk Copy 4.2 header."			);	} else {		ui3b Temp[checkheadersize];		ui5r n = checkheadersize;		if (noErr == (err = ProgressBar_SetStage_v2(			"Reading header\311", 0)))		if (noErr == (err =			DiskRead_v2(Temp, InsertInVol, checkheaderoffset, &n)))		{			ui5r DataSize0 = do_get_mem_long(				&Temp[kDC42offset_dataSize]);			ui5r TagSize0 = do_get_mem_long(				&Temp[kDC42offset_tagSize]);			ui5r dataChecksum0 = do_get_mem_long(				&Temp[kDC42offset_dataChecksum]);			ui5r tagChecksum0 = do_get_mem_long(				&Temp[kDC42offset_tagChecksum]);			ui5r DataOffset0 = kDC42offset_userData;			ui5r TagOffset0 = DataOffset0 + DataSize0;			if (0x0100 != do_get_mem_word(&Temp[kDC42offset_private]))			{				UpdtProgressAlertFromCStr(					"Wrong signature for a Disk Copy 4.2 disk image.");			} else if (0 != (DataSize0 & 0x01FF)) {				UpdtProgressAlertFromCStr(					"Data size is not multiple of block size.");			} else if ((DataSize0 >> 9) < 4) {				UpdtProgressAlertFromCStr("Data size too small.");			} else if (Temp[kDC42offset_diskName] >= 64) {				/* length of pascal string */				UpdtProgressAlertFromCStr(					"Original disk name in image too long.");			} else if (L < (TagOffset0 + TagSize0)) {				UpdtProgressAlertFromCStr(					"The image is shorter than expected.");			} else {				if (0 == TagSize0) {					/* no tags */					FormatOk = trueblnr;				} else if ((DataSize0 >> 9) * 12					== TagSize0)				{					/* 12 byte tags */					FormatOk = trueblnr;				} else {					UpdtProgressAlertFromCStr(						"I don't support the tag size used"						" in this Disk Copy 4.2 disk image.");				}			}			if (FormatOk) {				ui5r dataChecksum;				FormatOk = falseblnr;				if (noErr == (err = ProgressBar_SetStage_v2(					"Checksumming data\311", DataSize0)))				if (noErr == (err = DC42BlockChecksum(InsertInVol,					DataOffset0, DataSize0, &dataChecksum)))				{					if (dataChecksum != dataChecksum0) {						UpdtProgressAlertFromCStr("bad dataChecksum");					} else {						FormatOk = trueblnr;					}				}			}			if (FormatOk) {				FormatOk = falseblnr;				if (TagSize0 >= 12) {					ui5r tagChecksum;					/*						Checksum of tags doesn't include first block.						presumably because of bug in original disk						copy program.					*/					TagOffset0 += 12;					TagSize0 -= 12;					if (noErr == (err = ProgressBar_SetStage_v2(						"Checksumming tags\311", TagSize0)))					if (noErr == (err = DC42BlockChecksum(InsertInVol,						TagOffset0, TagSize0, &tagChecksum)))					{						if (tagChecksum != tagChecksum0) {							UpdtProgressAlertFromCStr(								"bad tagChecksum");						} else {							FormatOk = trueblnr;						}					}				} else {					if (0 != tagChecksum0) {						UpdtProgressAlertFromCStr(							"Non Zero tagChecksum, though no tags.");					} else {						FormatOk = trueblnr;					}				}			}		}	}	if (FormatOk) {		if (noErr == (err = ProgressBar_SetStage_v2(			"Finished", 0)))		{			UpdtProgressAlertFromCStr(				"Good -"				" I think that is a valid Disk Copy 4.2 disk image.");		}	}	return err;}LOCALPROC TryCheckHostFile(void){	tMyErr err;	tDrive InsertInVol;	ui5b L;	if (TryCaptureInsert(&InsertInVol)) {		if (noErr == (err = DiskGetSize_v2(InsertInVol, &L)))		if (noErr == (err = CheckIsDC42Format(InsertInVol, L)))		{		}		err = CombineErr(err, DiskEject_v2(InsertInVol));		err = CombineErr(err, ProgressBar_SetStage_v2((noErr == err)			? "Done, ready to check another\311"				: "Aborted, ready to check another\311",			0));		if (kMyErrUsrCancel != err) {			(void) CheckSysErr(err);		}	}}LOCALPROC ProgramMain(void){	while (! ProgramDone) {		UpdateProgressBar();		ReportErrors();		MyDoNextEvents(CapturingInserts ? 5			: 5 * 60 * 60);		CheckStateAfterEvents();		if (CapturingInserts) {			TryCheckHostFile();		}	}}LOCALPROC ProgramZapVars(void){}LOCALPROC ProgramPreInit(void){	OneWindAppPreInit();}LOCALFUNC blnr ImportExtnInit(void){	ui4r version;	ui5b features;	blnr IsOk = falseblnr;	if (! (noErr == HaveDiskExtenstion_v2())) {		MyAlertFromCStr(			"The Mini vMac extension mechanism is not available.");	} else if (! CheckSysErr(DiskVersion_v2(&version))) {	} else if (version < 2) {		MyAlertFromCStr("The Disk Extension version is too old.");	} else if (! CheckSysErr(DiskFeatures_v2(&features))) {	} else if (0 == (features & ((ui5b)1 << kFeatureCmndDisk_RawMode)))	{		MyAlertFromCStr("Raw mode access feature is not available.");	} else if (0 == (features & ((ui5b)1 << kFeatureCmndDisk_GetName)))	{		MyAlertFromCStr("Get Disk name feature is not available.");	} else {		IsOk = trueblnr;	}	return IsOk;}LOCALFUNC blnr ProgramInit(void){	if (CheckSysErr(MyMemory_Init_v2()))	if (ImportExtnInit())	if (CheckSysErr(OneWindAppInit_v2()))	{		return trueblnr;	}	return falseblnr;}LOCALPROC ProgramUnInit(void){	CapturingInsertsOff();	OneWindAppUnInit();	MyMemory_UnInit();}int main(void){	ProgramZapVars();	ProgramPreInit();	if (ProgramInit()) {		ProgramMain();	}	ProgramUnInit();	return 0;}