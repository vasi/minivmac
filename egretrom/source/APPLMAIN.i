/*	APPLMAIN.c	Copyright (C) 2010 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	APPLication MAIN*//*	Cuda Manager partial API	from Apple Technical Note TN1079	and communication with R. Belmont*/#define LMGetCudaBase() (*(ui5b *) 0x0DE0)LOCALFUNC blnr CheckForCuda(void){	blnr v = falseblnr;#if 1	if (! OSTrapAvailable(0xA092)) {		MyAlertFromCStr("_EgretDispatch is not available.");	} else if (LMGetCudaBase() == -1) {		MyAlertFromCStr("Cuda Manager software is not loaded.");	} else#endif	{		v = trueblnr;	}	return v;}#define pseudoPkt       0x01    /* Cuda Pseudo Packet               */#define EnDisFileS      0x13    /* enable/disable file server flag  */#define WakeupMode      0x23    /* Enable/Disable WakeUp Mode       */#define GetPwrFailTime  0x27    /* read time of last power failure  */struct CudaPB {	unsigned char       pbCmdType;      /* Command Type,  always  'pseudoPkt' */	unsigned char       pbCmd;          /* Command */	union {                             /* parameter to pass */		unsigned char   pByte[4];		unsigned short  pWord[2];		unsigned long   pLong;	} pbParam;	unsigned short      pbByteCnt;      /* Number of bytes passed in buffer */	unsigned char       *pbBufPtr;      /* Pointer to a buffer. */	unsigned char       pbFlags;        /* Flags returned by Cuda */	unsigned char       pbSpare;        /* reserved */	short               pbResult;       /* Result code returned by Cuda */	ProcPtr             pbCompletion;   /* Routine to be called on completion */};typedef struct CudaPB CudaPB;typedef CudaPB * CudaPbPtr;/*	Apple's TN1079 doesn't say anything about returning result code	in D0, but presumably it does.*/#if PRAGMA_PARAMETER#pragma parameter __D0 Cuda(__A0)#endifpascal OSErrCuda(CudaPB* myPB)	= {#if PRAGMA_PARAMETER		0xA092#else		0x205F, /* MOVEA.L    (A7)+,A0 */		0xA092, /* _EgretDispatch */		0x3E80  /* MOVE.W     D0,(A7) */#endif	};#define RomBase 0x0F00#define RomLength 0x1100	/*		Really? That's very odd.	*/#define MaxEgretTransfer 4	/*		R. Belmont says:		I'd stay at 8 or less per call -		it looks like some internal limits may be hit otherwise	*/LOCALFUNC tMyErr ReadEgretROM(Handle RomH){	tMyErr err;	Ptr p = *RomH;	uimr offset = RomBase;	uimr L = RomLength;	HLock(RomH);Label_1:	if (L == 0) {		err = noErr;	} else {		ui5r n = (L > MaxEgretTransfer) ? MaxEgretTransfer : L;		if (noErr == (err = CheckAbortRequested())) {#if 0			/*				dummy code - so can develop rest of application				without a machine with Cuda.			*/			uimr t = LMGetTicks();			while (t == LMGetTicks()) {			}			*(ui5b *)p = L;#else			CudaPB thePB;			thePB.pbCmdType = pseudoPkt;			thePB.pbCmd = 0x2; /* read 6805 memory */			thePB.pbParam.pWord[0]  = offset; /* address to read in 6805 memory */			thePB.pbParam.pWord[1]  = 0;			thePB.pbByteCnt = n; /* count of bytes expected back */			thePB.pbBufPtr = p; /* pointer to buffer to receive returned data */			thePB.pbFlags = 0; /* flags returned from Egret */			thePB.pbSpare = 0;			thePB.pbResult = 0; /* result code, if any */			thePB.pbCompletion = nil;			if (noErr != (err = Cuda(&thePB))) {				MyAlertFromCStr("Cuda returned error.");				err = kMyErrReported;			} else#endif			{				L -= n;				p += n;				offset += n;				ProgressBarVal += n;				goto Label_1;			}		}	}	HUnlock(RomH);	return err;}#define MyCreator 'MnvM'#define MyFileType 'ROM!'LOCALFUNC tMyErr WriteEgretROM(Handle RomH){	/* adapt code from CopyRoms */	tMyErr err;	ParamBlockRec b;	short VRefNum;	StringPtr MyFileName = ((StringPtr)"\pEgret.ROM");	/*		"use low level calls, since glue for higher level		calls provided with my development environment do not		work on Macintosh 128K." (originally. now just		leave this in, instead of using FILUTIL.i, since		it is already written. Using the low level stuff		directly is more efficient, if less clear.)	*/	b.ioParam.ioCompletion = 0;	b.ioParam.ioNamePtr = 0;	if (noErr == (err = PBGetVolSync(&b))) {		VRefNum = b.ioParam.ioVRefNum;		b.ioParam.ioNamePtr = MyFileName;		b.ioParam.ioVersNum = 0;		err = PBCreateSync(&b);		if (err == dupFNErr) {			if (noErr == PBDeleteSync(&b)) {				err = PBCreateSync(&b);			}		}		if (noErr == err) {			b.ioParam.ioPermssn = fsRdWrPerm;			b.ioParam.ioMisc = 0;			if (noErr == (err = PBOpenSync(&b))) {				HLock(RomH);				b.ioParam.ioBuffer = *RomH;				b.ioParam.ioReqCount = RomLength;				b.ioParam.ioPosMode = fsFromStart;				b.ioParam.ioPosOffset = 0;				err = PBWriteSync(&b);				HUnlock(RomH);				err = CombineErr(err, PBCloseSync(&b));				b.fileParam.ioNamePtr = MyFileName;				b.fileParam.ioVRefNum = VRefNum;				b.fileParam.ioFVersNum = 0;				b.fileParam.ioFDirIndex = 0;				if (noErr == (err = PBGetFInfoSync(&b))) {					b.fileParam.ioFlFndrInfo.fdType = MyFileType;					b.fileParam.ioFlFndrInfo.fdCreator = MyCreator;					err = PBSetFInfoSync(&b);				}			}		}	}	return err;}LOCALPROC ProgramMain(void){	tMyErr err;	Handle RomH;	if (noErr == (err = MyHandleNew_v2(RomLength, &RomH))) {		if (noErr == (err = ProgressBar_SetStage_v2("Reading, type command period to abort", RomLength)))		if (noErr == (err = ReadEgretROM(RomH)))		{			err = WriteEgretROM(RomH);		}		DisposeHandle(RomH);	}	if (kMyErrUsrCancel != err) {		(void) CheckSysErr(err);	}}LOCALPROC ProgramZapVars(void){}LOCALPROC ProgramPreInit(void){	OneWindAppPreInit();}LOCALFUNC blnr ProgramInit(void){	if (CheckSysErr(MyMemory_Init_v2()))	if (CheckForCuda())	if (CheckSysErr(OneWindAppInit_v2()))	{		return trueblnr;	}	return falseblnr;}LOCALPROC ProgramUnInit(void){	OneWindAppUnInit();	MyMemory_UnInit();}int main(void){	ProgramZapVars();	ProgramPreInit();	if (ProgramInit()) {		ProgramMain();	}	ProgramUnInit();	return 0;}