/*	BINPRGIN.i	Copyright (C) 2008 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	"BINary" PRoGram INput	For reading the data fork of binary file a byte at	a time, buffered.	Optionally, as data is read it is also saved	to a small "line" buffer. Example of use:	After the calling code disassembles one instruction,	it can convert the opcodes to hex from the line buffer.	It is possible to move to another location in the	file, instead of strictly sequential access. But	if the new location isn't in the current buffer,	the current buffer is discarded. So this isn't	very good for truly random access.*/LOCALVAR short prgin_ref = NotAfileRef;LOCALVAR Handle prgin_h = nullpr;#define prgin_bufl2sz 14 /* log 2 segment size */#define prgin_bufsz PowOf2(prgin_bufl2sz)LOCALVAR uimr prgin_CL = 0;  /* current upper lower bounds */LOCALVAR uimr prgin_CU = 0;LOCALVAR uimr prgin_Mx = 0;LOCALVAR uimr prgin_i = 0;   /* program counter */LOCALVAR tMyErr prgin_err = noErr;GLOBALFUNC tMyErr prgin_close_v2(void){	/*		May be called even if prgin_open		fails or never called at all.	*/	tMyErr err = prgin_err;	prgin_err = noErr;	if (NotAfileRef != prgin_ref) {		err = CombineErr(err, MyCloseFile_v2(prgin_ref));		prgin_ref = NotAfileRef;	}	MyNHandleClear(&prgin_h);	prgin_i = 0;	prgin_CL = 0;	prgin_CU = 0;	prgin_Mx = 0;	return err;}LOCALFUNC blnr prgin_loadcontaining(void){	tMyErr err;	blnr IsOK = falseblnr;	if ((noErr == prgin_err) && (prgin_i < prgin_Mx)) {		prgin_CL = FloorPow2Mult(prgin_i, prgin_bufl2sz);		prgin_CU = prgin_CL + prgin_bufsz;		if (prgin_CU > prgin_Mx) {			prgin_CU = prgin_Mx;		}		err = MyBackReadBytes_v2(prgin_ref, prgin_CL,			(MyPtr)*prgin_h, prgin_CU - prgin_CL);		if (noErr != err) {			prgin_err = err;		} else {			IsOK = trueblnr;		}	}	return IsOK;}GLOBALFUNC tMyErr prgin_open_v2(MyDir_R *d, StringPtr s){	tMyErr err;	if (NotAfileRef != prgin_ref) {		MyAlertFromCStr(			"program bug - prgin_open_v2 may not be nested");		err = kMyErrReported;	} else {		err = MyFileOpen_v2(d, s, (char)fsRdPerm, &prgin_ref);		if (fnfErr == err) {			MyAlertFromCStr(				/* use c preprocessor string concatenation */				"I can't find the file to disassemble."				" It should be named \"bin\" and placed"				" in the same folder as this program."				);			err = kMyErrReported;		} else if (noErr == err) {			if (noErr == (err = MyHandleNew_v2(prgin_bufsz, &prgin_h)))			if (noErr == (err = MyOpenFileGetEOF_v2(				prgin_ref, &prgin_Mx)))			{				/* ok */			}			if (noErr != err) {				(void) prgin_close_v2();					/* ignore any error, since already got one */			}		}	}	return err;}LOCALPROC prgin_seek(uimr i){	if (i < prgin_CL) {		prgin_CL = 0;		prgin_CU = 0;	}	prgin_i = i;}#ifndef prgin_wantlinbuf#define prgin_wantlinbuf 0#endif#if prgin_wantlinbuf#define linbufl2sz 5#define linbufsz PowOf2(linbufl2sz)LOCALVAR ui3b linbufa[linbufsz];LOCALVAR ui4r linbufi = 0;#define linbuf_reset() (linbufi = 0)#endifLOCALFUNC ui3r prgin_readByte(void){	ui3r v;	if (prgin_i >= prgin_CU) {		if (! prgin_loadcontaining()) {			return 0; /* need to handle this for real */		}	}	v = ((ui3b *)*prgin_h)[prgin_i - prgin_CL];#if prgin_wantlinbuf	linbufa[ModPow2(linbufi++, linbufl2sz)] = v;#endif	prgin_i += 1;	return v;}LOCALFUNC ui4r prgin_readWord(void){	ui4r b0 = prgin_readByte();	ui4r b1 = prgin_readByte();	return (b0 << 8) | b1;}LOCALFUNC ui5r prgin_readLong(void){	ui5r b0 = prgin_readWord();	ui5r b2 = prgin_readWord();	return (b0 << 16) | b2;}