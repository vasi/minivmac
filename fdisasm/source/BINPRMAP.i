/*	BINPRMAP.i	Copyright (C) 2008 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	"BINary" PRogram MAP*/#ifndef binmap_readonly#define binmap_readonly 0#endifLOCALVAR uimr binmap_n = 0;LOCALVAR uimr binmap_alloc = 0;LOCALVAR ui5h binmap_addr = nullpr;LOCALVAR ui4h binmap_kind = nullpr;#define binmap_kNotInFile 0#define binmap_kUnexplored 1LOCALPROC binmap_dispose(void){	MyNHandleClear((Handle *)&binmap_addr);	MyNHandleClear((Handle *)&binmap_kind);	binmap_n = 0;	binmap_alloc = 0;}LOCALFUNC tMyErr binmap_SetSize_v2(uimr binmap_newalloc){	tMyErr err;	if (noErr == (err = MyNHandleSetLen_v2(		(Handle *)&binmap_addr, binmap_newalloc * sizeof(uimr))))	if (noErr == (err = MyNHandleSetLen_v2(		(Handle *)&binmap_kind, binmap_newalloc * sizeof(ui4b))))	{		/* ok */	}	return err;}LOCALFUNC tMyErr binmap_SetMinAlloc_v2(uimr binmap_minalloc){	tMyErr err;#if binmap_readonly	uimr binmap_newalloc = binmap_minalloc;#else	uimr binmap_newalloc = CeilPowerOf2(binmap_minalloc);#endif	if (binmap_newalloc == binmap_alloc) {		err = noErr;	} else {		if (noErr != (err = binmap_SetSize_v2(binmap_newalloc))) {			if (binmap_newalloc > binmap_alloc) {				(void) binmap_SetSize_v2(binmap_alloc);					/* ignore any error, since already got one */				goto error_exit;			}		}		binmap_alloc = binmap_newalloc;	}error_exit:	return err;}#if ! binmap_readonlyGLOBALFUNC tMyErr binmap_save_v2(MyDir_R *d, ps3p s){	tMyErr err;	uimr x;	if (noErr == (err = strmo_open_v2(d, s))) {		for (x = 0; x < binmap_n - 2; ++x) {			strmo_Simr2Hex((*binmap_addr)[x]);			strmo_writeSpace();			strmo_Simr2Hex((*binmap_kind)[x]);			strmo_writeReturn();		}		err = strmo_close_v2();	}	return err;}#endifLOCALFUNC tMyErr binmap_scan_v2(MyDir_R *d, ps3p s){	/*		figure out maximum size, if in valid format.		(currently may be one too large.)	*/	tMyErr err;	uimr x;	x = 1;	if (noErr == (err = token_open_v2(d, s, nullpr))) {		while (token_kEof != token_kind) {			token_advance();			token_advance();			++x;		}		err = token_close_v2();	}	if (noErr == err) {		x += 2;		if (x > binmap_alloc) {			if (noErr == (err = binmap_SetMinAlloc_v2(x))) {				/* ok */			}		}	}	return err;}LOCALFUNC tMyErr binmap_loadone(uimr address, ui4r kind){	uimr x = binmap_n;	if (x >= binmap_alloc) {		return kMyErrParamErr;	} else {		(*binmap_addr)[x] = address;		(*binmap_kind)[x] = kind;		binmap_n = x + 1;		return noErr;	}}GLOBALFUNC tMyErr binmap_load_v2(MyDir_R *d, ps3p s){	tMyErr err;	uimr address;	uimr lastaddress;	ui4r kind;	if (noErr == (err = binmap_scan_v2(d, s))) {		lastaddress = 0;		if (noErr == (err = binmap_loadone(0, binmap_kUnexplored)))		if (noErr == (err = token_open_v2(d, s, nullpr)))		{label_retry:			if (token_kEof == token_kind) {				if (prgin_Mx <= lastaddress) {					MyAlertFromCStr("map goes too high");					err = kMyErrReported;				} else {					if (noErr == (err = binmap_loadone(						prgin_Mx, binmap_kNotInFile)))					if (noErr == (err = binmap_loadone(						2147483647, binmap_kNotInFile)))					{						/* ok */					}				}			} else {				address = token_getHex2Uimr();				kind = token_getHex2Uimr();				if (address <= lastaddress) {					if ((0 == lastaddress) && (0 == address)) {						(*binmap_kind)[0] = kind;						goto label_retry;					} else {						MyAlertFromCStr("map not ascending");						err = kMyErrReported;					}				} else if (noErr == (err = binmap_loadone(					address, kind)))				{					lastaddress = address;					goto label_retry;				}			}			err = CombineErr(err, token_close_v2());		}	}	return err;}#if ! binmap_readonlyGLOBALFUNC tMyErr binmap_set_v2(uimr rangebottom, uimr rangetop,	ui4r rangekind){	tMyErr err;	uimr i;	uimr j;	uimr x;	uimr delbot;	uimr deltop;	uimr oldsz;	uimr d;	ui4r toptype;	uimr binmap_newn;	j = binmap_n;	while ((*binmap_addr)[j - 1] > rangetop) {		j--;	}	i = j;	while ((i != 0) && ((*binmap_addr)[i - 1] >= rangebottom)) {		i--;	}	if ((i != 0) && ((*binmap_kind)[i - 1] == rangekind)) {		i--;		delbot = (*binmap_addr)[i];	} else {		delbot = rangebottom;	}	/* i is now first element to be replaced */	toptype = (*binmap_kind)[j - 1];	if (toptype == rangekind) {		deltop = (*binmap_addr)[j];		toptype = (*binmap_kind)[j];		j++;	} else {		deltop = rangetop;	}	/* j is now first element to be kept */	oldsz = j - i;	if (2 > oldsz) {		d = 2 - oldsz;		binmap_newn = binmap_n + d;		if (binmap_newn > binmap_alloc) {			err = binmap_SetMinAlloc_v2(binmap_newn);			if (noErr != err) {				return err;			}		}		for (x = binmap_n; x-- > j; ) {			/* x goes from binmap_n - 1 down to j */			(*binmap_addr)[x + d] = (*binmap_addr)[x];			(*binmap_kind)[x + d] = (*binmap_kind)[x];		}		binmap_n = binmap_newn;	} else if (oldsz > 2) {		d = oldsz - 2;		for (x = j; x < binmap_n; ++x) {			(*binmap_addr)[x - d] = (*binmap_addr)[x];			(*binmap_kind)[x - d] = (*binmap_kind)[x];		}		binmap_n -= d;	}	(*binmap_addr)[i] = delbot;	(*binmap_kind)[i] = rangekind;	(*binmap_addr)[i + 1] = deltop;	(*binmap_kind)[i + 1] = toptype;	return noErr;}#endifstruct rngtp {	uimr bottom;	uimr top;	ui4r kind;};typedef struct rngtp rngtp;LOCALPROC binmap_find(uimr where, rngtp *range){	uimr x;	x = binmap_n - 1;	while ((*binmap_addr)[x] > where) {		x--;	}	range->bottom = (*binmap_addr)[x];	range->top = (*binmap_addr)[x + 1];	range->kind = (*binmap_kind)[x];}LOCALVAR uimr binmap_iterI;LOCALVAR uimr binmap_iterAddr;LOCALVAR ui4r binmap_iterKind;LOCALVAR blnr binmap_iterDone;LOCALPROC binmap_iterNext(void){	if (binmap_iterI < binmap_n) {		binmap_iterAddr = (*binmap_addr)[binmap_iterI];		binmap_iterKind = (*binmap_kind)[binmap_iterI];		++binmap_iterI;	} else {		binmap_iterDone = trueblnr;	}}LOCALPROC binmap_iterBegin(void){	binmap_iterI = 0;	binmap_iterDone = falseblnr;	binmap_iterNext();}