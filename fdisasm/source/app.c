/*	Copyright (C) 2014 Paul Pratt, Rob	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	Decoding of selected MMU instructions by Rob*/#define IsAnApp 1#include "MYMACAPI.i"#define WantOptMoveBytes 1#include "COREDEFS.i"#include "POW2UTIL.i"#include "STRUTILS.i"#include "MACENVRN.i"#include "MACINITS.i"#include "SAVEDERR.i"#include "FILEUTIL.i"#include "MYMEMORY.i"#include "XBUFHAND.i"#include "MYFPMATH.i"#define WantRealInputFile 0#include "PROGRBAR.i"#include "PROGWND1.i"#include "HEXCONVR.i"#include "STRMOUTT.i"#include "STREAMIN.i"#include "TOKENIZR.i"#define prgin_wantlinbuf 1#include "BINPRGIN.i"#define binmap_readonly 1#include "BINPRMAP.i"enum {	sym_kTableRel,	sym_kTableA5,	sym_kTableTraps,	sym_kTableAbs,	sym_NTables};LOCALFUNC ps3p sym_TableName(ui4r table){	ps3p p = NULL;	switch (table) {		case sym_kTableRel:			p = (StringPtr)"\pbin_names";			break;		case sym_kTableA5:			p = (StringPtr)"\pA5_names";			break;		case sym_kTableTraps:			p = (StringPtr)"\ptrap_names";			break;		case sym_kTableAbs:			p = (StringPtr)"\pabs_names";			break;	}	return p;}#include "SYMTABLS.i"/* -- numconv -- */#define extb(x) ((simr)(si3b)(x))#define extw(x) ((simr)(si4b)(x))LOCALPROC bytehex(ui3r x, ps3p s){	short z;	MyCharPtr p = s + 3;	for (z = 2; z > 0; --z) {		*--p = hexdv[ModPow2(x, 4)];		x >>= 4;	}	*--p = 2;}LOCALPROC wordhex(ui4r x, ps3p s){	short z;	MyCharPtr p = s + 5;	for (z = 4; z > 0; --z) {		*--p = hexdv[ModPow2(x, 4)];		x >>= 4;	}	*--p = 4;}LOCALPROC longhex(ui5r x, ps3p s){	short z;	MyCharPtr p = s + 9;	for (z = 8; z > 0; --z) {		*--p = hexdv[ModPow2(x, 4)];		x >>= 4;	}	*--p = 8;}#define binmap_kIsCode 2#define binmap_kIsNotCode 3/* for addressing mode 10 */#define am10_CCR 0#define am10_SR 1#define am10_USP 2#define am10_post 4#define am10_pre 5#define BitAnd(x, y) (((uimr)(x)) & ((uimr)(y)))/* -- disemglue -- */LOCALVAR Str255 op; /* opcode nmemonic */LOCALVAR simr opsize; /* opsize attribute of opcode */LOCALVAR simr argn; /* number of arguments */LOCALVAR Str255 lbl;LOCALVAR Str255 remark;LOCALVAR short words;LOCALVAR short indntc;LOCALVAR short glsize;LOCALVAR blnr doaddr;LOCALVAR blnr dohex;LOCALVAR blnr dorem;LOCALVAR blnr islabel;LOCALVAR blnr isremark;LOCALVAR uimr ii; /* current instruction starting address */LOCALVAR uimr ci; /* current operand starting address */LOCALVAR Str255 arg[2];enum {	decodemode_kUnknown,	decodemode_kData,	decodemode_n};LOCALVAR ui4r decodemode = decodemode_kUnknown;LOCALVAR ui4r decodemodedatsize;LOCALVAR blnr decoding_code = falseblnr;LOCALPROC dis_zap(void){	words = 3;	indntc = 1;	glsize = 11;	doaddr = true;	dohex = true;	dorem = true;	islabel = false;	isremark = false;	PStrClear(lbl);	PStrClear(remark);}LOCALPROC PStrApndSimrCnst2Hex(ps3p s, simr v){	if (v < 0) {		v = - v;		PStrApndChar(s, '-');	}	PStrApndChar(s, '$');	PStrApndUimr2Hex(s, v);}LOCALPROC PStrApndUimrCnst2Hex(ps3p s, simr v){	PStrApndChar(s, '$');	PStrApndUimr2Hex(s, v);}LOCALPROC pcrel(long offset, ps3p s){	uimr vv;	vv = offset + ci;	sym_translate(sym_kTableRel, vv, s);	if (! sym_found) {		PStrCopy(s, (StringPtr)"\p(* + ");		PStrApndSimrCnst2Hex(s, offset + (ci - ii));		PStrAppend(s, (StringPtr)"\p)");	}}LOCALPROC pcabs(long offset, ps3p p){	Str255 s;	sym_translate(sym_kTableAbs, offset, s);	if (! sym_found) {		PStrApndUimrCnst2Hex(p, offset);	} else {		PStrAppend(p, s);	}}LOCALPROC pcoffreg(long reg, long offset, ps3p s){	Str255 k;	PStrClear(s);	PStrApndSimrCnst2Hex(s, offset);	PStrAppend(s, (StringPtr)"\p(A");	PStrApndChar(s, hexdv[reg]);	PStrAppend(s, (StringPtr)"\p)");	if (reg == 5) {		sym_translate(sym_kTableA5, offset, k);		if (sym_found) {			PStrAppend(s, (StringPtr)"\p=");			PStrAppend(s, k);		}	}}LOCALPROC dis_disp_ea(ps3p p, blnr usereg, long reg){	ui4b dp = prgin_readWord();	int regno = (dp >> 12) & 0x0F;	uimr tt = (dp >> 8) & 0xFF;	simr offset = extb(dp & 0xFF);	if (dp & 0x0100) {		switch ((dp >> 4) & 0x03) {			case 2:				offset = (si5b)(si4b)prgin_readWord();				break;			case 3:				offset = prgin_readLong();				break;			default:				offset = 0;				break;		}	} else {		offset = extb(dp & 0xFF);	}	if (usereg) {		if ((dp & 0x0100) && ((dp & 0x03) != 0)) {			PStrFromChar(p, '(');			PStrAppend(p, (StringPtr)"\p[");			PStrApndSimrCnst2Hex(p, offset);			PStrAppend(p, (StringPtr)"\p, ");		} else {			PStrClear(p);			PStrApndSimrCnst2Hex(p, offset);			PStrAppend(p, (StringPtr)"\p(");		}		if (! ((dp & 0x0100) && ((dp & 0x80) != 0))) {			PStrAppend(p, (StringPtr)"\pA");			PStrApndChar(p, hexdv[reg]);		}		if ((dp & 0x0100) && ((dp & 0x03) != 0) && ((dp & 0x04) != 0)) {			PStrAppend(p, (StringPtr)"\p]");		}		PStrAppend(p, (StringPtr)"\p,");	} else {		pcrel(offset, p);		PStrAppend(p, (StringPtr)"\p(");		if ((dp & 0x0100) && ((dp & 0x03) != 0)) {			PStrAppend(p, (StringPtr)"\p[");		}		if ((dp & 0x0100) && ((dp & 0x03) != 0) && ((dp & 0x04) != 0)) {			PStrAppend(p, (StringPtr)"\p]");		}	}	if (! ((dp & 0x0100) && ((dp & 0x40) != 0))) {		PStrApndChar(p, TestBit(tt, 7) ? 'A' : 'D');		PStrApndChar(p, hexdv[ExtractBitField(tt, 4, 3)]);		PStrAppend(p, (StringPtr)"\p.");		PStrApndChar(p, TestBit(tt, 3) ? 'L' : 'W');		switch ((dp >> 9) & 3) {			case 1:				PStrAppend(p, (StringPtr)"\p*2");				break;			case 2:				PStrAppend(p, (StringPtr)"\p*4");				break;			case 3:				PStrAppend(p, (StringPtr)"\p*8");				break;			default:				/* nothing */				break;		}	}	if ((dp & 0x0100) && ((dp & 0x03) != 0) && ((dp & 0x04) == 0)) {		PStrAppend(p, (StringPtr)"\p]");	}	if ((dp & 0x0100) && ((dp & 0x03) != 0)) {		PStrAppend(p, (StringPtr)"\p,");		switch (dp & 0x03) {			case 2:				offset = (si5b)(si4b)prgin_readWord();				break;			case 3:				offset = prgin_readLong();				break;			default:				offset = 0;				break;		}		PStrApndSimrCnst2Hex(p, offset);	}	PStrAppend(p, (StringPtr)"\p)");}LOCALFUNC ui4r ReverseBitsWord(ui4r x){	si4r i;	ui4r v = 0;	for (i = 16; --i >= 0; )  {		v = (v << 1) | (x & 1);		x >>= 1;	}	return v;}LOCALPROC reglist0(ps3p result, ui4r x, ps3p rset){	short z;	short lastz = -1;	short firstz = -1;	x &= 0x00FF;	/* so works when run loop one too many times. */	for (z = 0; z <= 8; ++z) {		if (TestBit(x, z)) {			if (firstz < 0) {				firstz = z;				if (lastz >= 0) {					PStrApndChar(result, '/');				}			}			lastz = z;		} else {			/* will always get here on extra iteration */			if (firstz >= 0) {				PStrAppend(result, rset);				PStrApndChar(result, hexdv[firstz]);				if (firstz != lastz) {					PStrApndChar(result, '-');					PStrAppend(result, rset);					PStrApndChar(result, hexdv[lastz]);				}				firstz = -1;			}		}	}}LOCALPROC reglist(long reg, ps3p result){	ui4r x;	PStrClear(result);	x = prgin_readWord();	if (reg == am10_pre) {		x = ReverseBitsWord(x);	}	reglist0(result, x, (StringPtr)"\pD");	if ((x >> 8) != 0) {		if ((x & 0x00FF) != 0) {			PStrApndChar(result, '/');		}		reglist0(result, x >> 8, (StringPtr)"\pA");	}}LOCALPROC adec(short w, long mode, long reg){	simr offset;	ps3p p = arg[w];	switch (mode) {		case 0:			PStrCopy(p, (StringPtr)"\pD");			PStrApndChar(p, hexdv[reg]);			break;		case 1:			PStrCopy(p, (StringPtr)"\pA");			PStrApndChar(p, hexdv[reg]);			break;		case 2:			PStrCopy(p, (StringPtr)"\p(A");			PStrApndChar(p, hexdv[reg]);			PStrAppend(p, (StringPtr)"\p)");			break;		case 3:			PStrCopy(p, (StringPtr)"\p(A");			PStrApndChar(p, hexdv[reg]);			PStrAppend(p, (StringPtr)"\p)+");			break;		case 4:			PStrCopy(p, (StringPtr)"\p-(A");			PStrApndChar(p, hexdv[reg]);			PStrAppend(p, (StringPtr)"\p)");			break;		case 5:			offset = extw(prgin_readWord());			pcoffreg(reg, offset, p);			break;		case 6:			dis_disp_ea(p, trueblnr, reg);			break;		case 7:			switch (reg) {				case 0:					offset = extw(prgin_readWord());					PStrCopy(p, (StringPtr)"\p(");					pcabs(offset, p);					PStrAppend(p, (StringPtr)"\p)");					break;				case 1:					offset = (simr)prgin_readLong();					PStrCopy(p, (StringPtr)"\p(");					pcabs(offset, p);					PStrAppend(p, (StringPtr)"\p)");					break;				case 2:					ci = prgin_i;					pcrel(extw(prgin_readWord()), p);					break;				case 3:					ci = prgin_i;					dis_disp_ea(p, falseblnr, reg);					break;				case 4:					PStrCopy(p, (StringPtr)"\p#");					switch (opsize) {						case 1:							PStrApndUimrCnst2Hex(p, prgin_readWord());							break;						case 2:							PStrApndUimrCnst2Hex(p, prgin_readWord());							break;						case 4:							PStrApndUimrCnst2Hex(p,								(uimr)prgin_readLong());							break;					}					break;				default:					PStrCopy(p,						(StringPtr)"\pUnimplemented addressing mode");					break;			}			break;		case 8:			PStrCopy(p, (StringPtr)"\p#");			PStrApndSimrCnst2Hex(p, reg);			break;		case 9:			ci = prgin_i;			if (reg == 0) {				offset = extw(prgin_readWord());			} else if (reg == -1) {				offset = (simr)prgin_readLong();			} else {				offset = extb(reg);			}			pcrel(offset, p);			break;		case 10:			switch (reg) {				case am10_CCR:					PStrCopy(p, (StringPtr)"\pCCR");					break;				case am10_SR:					PStrCopy(p, (StringPtr)"\pSR");					break;				case am10_USP:					PStrCopy(p, (StringPtr)"\pUSP");					break;				case am10_pre:					reglist(reg, p);					break;				case am10_post:					reglist(reg, p);					break;				default:					PStrCopy(p,						(StringPtr)"\pUnimplemented addressing mode");					break;			}			break;		default:			PStrCopy(p, (StringPtr)"\pUnimplemented addressing mode");			break;	}}LOCALPROC DisasmControlReg(short w, ui4r i){	ps3p p = arg[w];	ps3p s;	switch (i) {		case 0x0000:			s = "\pSFC";			break;		case 0x0001:			s = "\pDFC";			break;		case 0x0002:			s = "\pCACR";			break;		case 0x0800:			s = "\pUSP";			break;		case 0x0801:			s = "\pVBR";			break;		case 0x0802:			s = "\pCAAR";			break;		case 0x0803:			s = "\pMSP";			break;		case 0x0804:			s = "\pISP";			break;		default:			s = "\p???";			break;	}	PStrCopy(p, s);}LOCALPROC invalidopcode(void){#if 0	fprintf(stdout,		"chk:invalidopcode--> unrecognized instruction %d ii %d\n",		prgin_i, ii);#endif}LOCALPROC aline(ui3r by1, ui3r by2){	ui4r trap;	Str255 t;	opsize = 0;	argn = 0;	trap = (ui4r)by1 * 256 + by2;	sym_translate(sym_kTableTraps, trap, op);	/* writeln('translating aline ',trap); */	if (! sym_found) {		PStrCopy(op, (StringPtr)"\pDC.W");		wordhex(trap, t);		PStrCopy(arg[0], (StringPtr)"\p$");		PStrAppend(arg[0], t);		argn = 1;		if (BitAnd(by1, 12) == 12) {			sym_translate(sym_kTableTraps,				BitAnd(by1, 251) * 256 + by2, t);			if (sym_found) {				PStrCopy(remark, t);				PStrAppend(remark, (StringPtr)"\p ,autopop");				isremark = dorem;			}		} else {			sym_translate(sym_kTableTraps,				(160 + BitAnd(1, by1)) * 256 + by2, t);			if (sym_found) {				PStrCopy(remark, (StringPtr)"\pmodified ");				PStrAppend(remark, t);				isremark = dorem;			}		}	}}LOCALPROC begininstruction(void){	linbuf_reset();	ii = prgin_i;}LOCALVAR uimr linestarts;LOCALPROC dis_writeBeforeColSpaces(uimr colstarts){	if (colstarts > strmo_bufpos) {		strmo_writeSpaces(colstarts - strmo_bufpos);	} else if (linestarts != strmo_bufpos) {		strmo_writeSpaces(1); /* minimum */	}}LOCALPROC BeginWriteInLabelField(void){	uimr colstarts = strmo_bufpos;	linestarts = colstarts;	if (doaddr) {		colstarts += 7;	}	if (dohex) {		colstarts += 5 * words;	}	dis_writeBeforeColSpaces(colstarts);}LOCALPROC WriteLabelLine(void){	BeginWriteInLabelField();	strmo_writePStr(lbl);	strmo_writeChar(':');	strmo_writeReturn();	islabel = false;}LOCALPROC endinstruction(void){	Str255 t;	short x;	short z;	short i;	uimr colstarts;	if (islabel && ((PStrLength(lbl) + 1) >= glsize)) {		WriteLabelLine();	}	colstarts = strmo_bufpos;	linestarts = colstarts;	if (doaddr) {		Uimr2Hex(ii, t);		strmo_writePStr(t);		colstarts += 7;	}	if (dohex) {		z = 2 * words;		if (z > linbufi) {			z = linbufi;		}		dis_writeBeforeColSpaces(colstarts);		strmo_writeHexByte((char)linbufa[0]);		for (i = 0; ++i < z; ) {			/* i goes from 1 to z-1 */			if (! IsOdd(i)) {				strmo_writeChar(' ');			}			strmo_writeHexByte((char)linbufa[i]);		}		colstarts += 5 * words;	}	/* always have this field */ {		if (islabel) {			dis_writeBeforeColSpaces(colstarts);			strmo_writePStr(lbl);			strmo_writeChar(':');		}		colstarts += glsize;		islabel = false;	}	/* always have this field */ {		dis_writeBeforeColSpaces(colstarts);		strmo_writePStr(op);		switch (opsize) {			case 0:				break;			case 1:				strmo_writePStr((StringPtr)"\p.B");				break;			case 2:				break;			case 4:				strmo_writePStr((StringPtr)"\p.L");				break;		}		colstarts += 10;		if (argn > 0) {			dis_writeBeforeColSpaces(colstarts);			strmo_writePStr(arg[0]);			for (x = 1; x < argn; ++x) {				strmo_writePStr((StringPtr)"\p, ");				strmo_writePStr(arg[x]);			}		}		colstarts += 16;	}	if (isremark) {		dis_writeBeforeColSpaces(colstarts);		strmo_writePStr((StringPtr)"\p; ");		strmo_writePStr(remark);		isremark = false;	}	strmo_writeReturn();	if (dohex) {		while (i < linbufi) {			if (doaddr) {				strmo_writeSpaces(7);			}			z = i + 2 * words;			if (z > linbufi) {				z = linbufi;			}			strmo_writeHexByte((char)linbufa[i]);			while (++i < z) {				if (! IsOdd(i)) {					strmo_writeChar(' ');				}				strmo_writeHexByte((char)linbufa[i]);			}			strmo_writeReturn();		}	}}/* -- disemone -- */struct decodeone_EnvRec {	long mode;	long reg;	long rg9;	long b76;	long b8;	long cond;};typedef struct decodeone_EnvRec decodeone_EnvRec;LOCALPROC blahcode(decodeone_EnvRec *decodeone_Env){	if (decodeone_Env->mode == 0) {		adec(0, 0, decodeone_Env->reg);		adec(1, 0, decodeone_Env->rg9);	} else {		adec(0, 4, decodeone_Env->reg);		adec(1, 4, decodeone_Env->rg9);	}	argn = 2;}LOCALPROC findsize(decodeone_EnvRec *decodeone_Env){	switch (decodeone_Env->b76) {		case 0:			opsize = 1;			break;		case 1:			opsize = 2;			break;		case 2:			opsize = 4;			break;	}}LOCALFUNC long octdat(long x){	long value_octdat;	if (x == 0) {		value_octdat = 8;	} else {		value_octdat = x;	}	return value_octdat;}LOCALPROC rolops(long x, decodeone_EnvRec *decodeone_Env){	switch (x) {		case 0:			PStrCopy(op, (StringPtr)"\pAs");			break;		case 1:			PStrCopy(op, (StringPtr)"\pLs");			break;		case 2:			PStrCopy(op, (StringPtr)"\pROX");			break;		case 3:			PStrCopy(op, (StringPtr)"\pRO");			break;	}	switch (decodeone_Env->b8) {		case 0:			PStrAppend(op, (StringPtr)"\pR");			break;		case 1:			PStrAppend(op, (StringPtr)"\pL");			break;	}}LOCALPROC bitop(decodeone_EnvRec *decodeone_Env){	switch (decodeone_Env->b76) {		case 0:			PStrCopy(op, (StringPtr)"\pBTst");			break;		case 1:			PStrCopy(op, (StringPtr)"\pBChg");			break;		case 2:			PStrCopy(op, (StringPtr)"\pBClr");			break;		case 3:			PStrCopy(op, (StringPtr)"\pBSet");			break;	}}LOCALPROC concod(ps3p b, decodeone_EnvRec *decodeone_Env){	PStrCopy(op, b);	switch (decodeone_Env->cond) {		case 0:			PStrAppend(op, (StringPtr)"\pT");			break;		case 1:			PStrAppend(op, (StringPtr)"\pF");			break;		case 2:			PStrAppend(op, (StringPtr)"\pHI");			break;		case 3:			PStrAppend(op, (StringPtr)"\pLS");			break;		case 4:			PStrAppend(op, (StringPtr)"\pCC");			break;		case 5:			PStrAppend(op, (StringPtr)"\pCS");			break;		case 6:			PStrAppend(op, (StringPtr)"\pNE");			break;		case 7:			PStrAppend(op, (StringPtr)"\pEQ");			break;		case 8:			PStrAppend(op, (StringPtr)"\pVC");			break;		case 9:			PStrAppend(op, (StringPtr)"\pVS");			break;		case 10:			PStrAppend(op, (StringPtr)"\pPL");			break;		case 11:			PStrAppend(op, (StringPtr)"\pMI");			break;		case 12:			PStrAppend(op, (StringPtr)"\pGE");			break;		case 13:			PStrAppend(op, (StringPtr)"\pLT");			break;		case 14:			PStrAppend(op, (StringPtr)"\pGT");			break;		case 15:			PStrAppend(op, (StringPtr)"\pLE");			break;	}}LOCALPROC decodeone(void){	/* decode one */	/*		Various compenents of the opcode,		defined at beginning of procedure	*/	ui4r opcode;	ui3r by1;	ui3r by2;	long nib1;	decodeone_EnvRec decodeone_Env;	begininstruction();	opcode = prgin_readWord();	by1 = (opcode >> 8) & 255;                      /* bits 8 ..15 */	by2 = opcode & 255;                             /* bits 0 .. 7 */	decodeone_Env.reg = opcode & 7;                 /* bits 0 .. 2 */	decodeone_Env.mode = (opcode >> 3) & 7;         /* bits 3 .. 5 */	decodeone_Env.b76 = (opcode >> 6) & 3;          /* bits 6 .. 7 */	decodeone_Env.b8 = (opcode >> 8) & 1;           /* bit  8      */	decodeone_Env.cond = BitAnd(by1, 15);           /* bits 8 ..11 */	decodeone_Env.rg9 = (opcode >> 9) & 7;          /* bits 9 ..11 */	nib1 = BitAnd(by1, 240) / 16;                   /* bits 12..15 */	switch (nib1) {		case 0:			if (decodeone_Env.b8 == 1) {				if (decodeone_Env.mode == 1) {					PStrCopy(op, (StringPtr)"\pMoveP");						/* Opcode = 0000ddd1mm001aaa */					opsize = BitAnd(decodeone_Env.b76, 1) * 2 + 2;					argn = 2;					if (decodeone_Env.b76 < 2) {						adec(0, 5, decodeone_Env.reg);						adec(1, 0, decodeone_Env.rg9);					} else {						adec(0, 0, decodeone_Env.rg9);						adec(1, 5, decodeone_Env.reg);					}				} else {					bitop(&decodeone_Env);						/* dynamic bit, Opcode = 0000ddd1ttmmmrrr */					if (decodeone_Env.mode == 0) {						opsize = 4;					} else {						opsize = 1;					}					argn = 2;					adec(0, 0, decodeone_Env.rg9);					adec(1, decodeone_Env.mode, decodeone_Env.reg);				}			} else {				if (decodeone_Env.rg9 == 4) {					bitop(&decodeone_Env);						/* static bit, Opcode = 00001000ssmmmrrr */					argn = 2;					opsize = 1;					adec(0, 7, 4);					if (decodeone_Env.mode == 0) {						opsize = 4;					} else {						opsize = 1;					}					adec(1, decodeone_Env.mode, decodeone_Env.reg);				} else if (decodeone_Env.b76 == 3) {					invalidopcode();				} else if (decodeone_Env.rg9 == 6) {					PStrCopy(op, (StringPtr)"\pCmpI");					findsize(&decodeone_Env);					argn = 2;					adec(0, 7, 4);					adec(1, decodeone_Env.mode, decodeone_Env.reg);				} else {					switch (decodeone_Env.rg9) {						case 0:							PStrCopy(op, (StringPtr)"\pOrI");							break;						case 1:							PStrCopy(op, (StringPtr)"\pAndI");							break;						case 2:							PStrCopy(op, (StringPtr)"\pSubI");							break;						case 3:							PStrCopy(op, (StringPtr)"\pAddI");							break;						case 5:							PStrCopy(op, (StringPtr)"\pEorI");							break;					}					findsize(&decodeone_Env);					argn = 2;					adec(0, 7, 4);					if ((decodeone_Env.mode == 7)						&& (decodeone_Env.reg == 4))					{						if (decodeone_Env.b76 == 0) {							adec(1, 10, 0);						}else {							adec(1, 10, 1);						}					} else {						adec(1, decodeone_Env.mode, decodeone_Env.reg);					}				}			}			break;		case 1:		case 2:		case 3:			PStrCopy(op, (StringPtr)"\pMove");			if (decodeone_Env.b8 * 4 + decodeone_Env.b76 == 1) {				PStrAppend(op, (StringPtr)"\pA");			}			switch (nib1) {				case 1:					opsize = 1;					break;				case 2:					opsize = 4;					break;				case 3:					opsize = 2;					break;			}			adec(0, decodeone_Env.mode, decodeone_Env.reg);			adec(1, decodeone_Env.b8 * 4 + decodeone_Env.b76,				decodeone_Env.rg9);			argn = 2;			break;		case 4:			/* Opcode = 4xxx */			if (decodeone_Env.b8 == 1) {				switch (decodeone_Env.b76) {					case 1:						invalidopcode();						break;					case 0:					case 2:						PStrCopy(op, (StringPtr)"\pChk");							/* Opcode = 0100ddd1s0mmmrrr */						opsize = 4 - decodeone_Env.b76;						adec(0, decodeone_Env.mode, decodeone_Env.reg);						adec(1, 0, decodeone_Env.rg9);						argn = 2;						break;					case 3:						PStrCopy(op, (StringPtr)"\pLea");							/* Opcode = 0100aaa111mmmrrr */						opsize = 4;						adec(0, decodeone_Env.mode, decodeone_Env.reg);						adec(1, 1, decodeone_Env.rg9);						argn = 2;						break;				}			} else {				switch (decodeone_Env.rg9) {					case 0:						if (decodeone_Env.b76 != 3) {							/* Opcode = 01000000ssmmmrrr */							PStrCopy(op, (StringPtr)"\pNegX");							findsize(&decodeone_Env);							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							argn = 1;						} else {							/* Opcode = 0100000011mmmrrr */							PStrCopy(op, (StringPtr)"\pMove");							opsize = 2;							adec(0, 10, am10_SR);							adec(1, decodeone_Env.mode,								decodeone_Env.reg);							argn = 2;						}						break;					case 1:						if (decodeone_Env.b76 != 3) {							/* Opcode = 01000010ssmmmrrr */							PStrCopy(op, (StringPtr)"\pClr");							findsize(&decodeone_Env);							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							argn = 1;						} else {							/* Opcode = 0100001011mmmrrr */							PStrCopy(op, (StringPtr)"\pMove");							opsize = 2;							adec(0, 10, am10_CCR);							adec(1, decodeone_Env.mode,								decodeone_Env.reg);							argn = 2;						}						break;					case 2:						if (decodeone_Env.b76 != 3) {							/* Opcode = 01000100ssmmmrrr */							PStrCopy(op, (StringPtr)"\pNeg");							findsize(&decodeone_Env);							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							argn = 1;						} else {							/* Opcode = 0100010011mmmrrr */							PStrCopy(op, (StringPtr)"\pMove");							opsize = 2;							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							adec(1, 10, am10_CCR);							argn = 2;						}						break;					case 3:						if (decodeone_Env.b76 != 3) {							/* Opcode = 01000110ssmmmrrr */							PStrCopy(op, (StringPtr)"\pNot");							findsize(&decodeone_Env);							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							argn = 1;						} else {							/* Opcode = 0100011011mmmrrr */							PStrCopy(op, (StringPtr)"\pMove");							opsize = 2;							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							adec(1, 10, 1);							argn = 2;						}						break;					case 4:						switch (decodeone_Env.b76) {							case 0:								/* Opcode = 0100100000mmmrrr */								PStrCopy(op, (StringPtr)"\pNbcd");								opsize = 1;								adec(0, decodeone_Env.mode,									decodeone_Env.reg);								argn = 1;								break;							case 1:								if (decodeone_Env.mode == 0) {									/* Opcode = 0100100001000rrr */									PStrCopy(op, (StringPtr)"\pSwap");									opsize = 2;									adec(0, 0, decodeone_Env.reg);									argn = 1;								} else {									/* Opcode = 0100100001mmmrrr */									PStrCopy(op, (StringPtr)"\pPea");									opsize = 4;									adec(0, decodeone_Env.mode,										decodeone_Env.reg);									argn = 1;								}								break;							case 2:							case 3:								if (decodeone_Env.mode == 0) {									/* Opcode = 010010001s000ddd */									PStrCopy(op, (StringPtr)"\pExt");									opsize = 2 * decodeone_Env.b76 - 2;									adec(0, decodeone_Env.mode,										decodeone_Env.reg);									argn = 1;								} else {									/* Opcode = 010010001smmmrrr */									PStrCopy(op, (StringPtr)"\pMoveM");									opsize = 2 * decodeone_Env.b76 - 2;									argn = 2;									if (decodeone_Env.mode == 4) {										adec(0, 10, am10_pre);									} else {										adec(0, 10, am10_post);									}									adec(1, decodeone_Env.mode,										decodeone_Env.reg);								}								break;						}						break;					case 5:						if (decodeone_Env.b76 != 3) {							/* Opcode = 01001010ssmmmrrr */							PStrCopy(op, (StringPtr)"\pTst");							findsize(&decodeone_Env);							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							argn = 1;						} else {							/* Opcode = 0100101011mmmrrr */							PStrCopy(op, (StringPtr)"\pTas");							opsize = 1;							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							argn = 1;						}						break;					case 6:						/* Opcode = 010011001smmmrrr */						PStrCopy(op, (StringPtr)"\pMoveM");						opsize = 2 * decodeone_Env.b76 - 2;						argn = 2;						adec(1, 10, am10_post);						adec(0, decodeone_Env.mode, decodeone_Env.reg);						break;					case 7:						switch (decodeone_Env.b76) {							case 0:								invalidopcode();								break;							case 1:								switch (decodeone_Env.mode) {									case 0:									case 1:										/* Opcode = 010011100100vvvv */										PStrCopy(op,											(StringPtr)"\pTrap");										opsize = 0;										adec(0, 8, BitAnd(by2, 15));										argn = 1;										break;									case 2:										/* Opcode = 0100111001010aaa */										PStrCopy(op,											(StringPtr)"\pLink");										opsize = 2;										adec(0, 1, decodeone_Env.reg);										adec(1, 8,											extw(prgin_readWord()));										argn = 2;										break;									case 3:										/* Opcode = 0100111001011aaa */										PStrCopy(op,											(StringPtr)"\pUnlk");										opsize = 0;										adec(0, 1, decodeone_Env.reg);										argn = 1;										break;									case 4:										/* Opcode = 0100111001100aaa */										PStrCopy(op,											(StringPtr)"\pMove");										opsize = 4;										adec(0, 1, decodeone_Env.reg);										adec(1, 10, am10_USP);										argn = 2;										break;									case 5:										/* Opcode = 0100111001101aaa */										PStrCopy(op,											(StringPtr)"\pMove");										opsize = 4;										adec(0, 10, am10_USP);										adec(1, 1, decodeone_Env.reg);										argn = 2;										break;									case 6:										opsize = 0;										argn = 0;										if (decodeone_Env.reg > 1) {											/* stop = true; */										}							/* indent left */							switch (decodeone_Env.reg) {								case 0:									/* Opcode = 0100111001100000 */									PStrCopy(op,										(StringPtr)"\pReset");									break;								case 1:									/* Opcode = 0100111001110001 */									PStrCopy(op, (StringPtr)"\pNop");									break;								case 2:									/* Opcode = 0100111001110010 */									PStrCopy(op, (StringPtr)"\pStop");									break;								case 3:									/* Opcode = 0100111001110011 */									PStrCopy(op, (StringPtr)"\pRte");									break;								case 4:									/* Opcode = 0100111001110100 */									PStrCopy(op, (StringPtr)"\pRtd");									opsize = 2;									adec(0, 7, 4);									argn = 1;									break;								case 5:									/* Opcode = 0100111001110101 */									PStrCopy(op, (StringPtr)"\pRts");									break;								case 6:									/* Opcode = 0100111001110110 */									PStrCopy(op, (StringPtr)"\pTrapV");									break;								case 7:									/* Opcode = 0100111001110111 */									PStrCopy(op, (StringPtr)"\pRtr");									break;							}										break;									case 7:							/* indent left */							if (BitAnd(decodeone_Env.reg, 6)								== 2)							{								ui4r extra = prgin_readWord();								ui4r ctrlr = extra & 0x0FFF;								ui4r regno = (extra >> 12) & 0x0F;								short admd = (regno > 8) ? 1 : 0;								ui4r regi = regno & 7;								PStrCopy(op,									(StringPtr)"\pMOVEC");								if (0 != (opcode & 1)) {									adec(0, admd, regi);									DisasmControlReg(1, ctrlr);								} else {									DisasmControlReg(0, ctrlr);									adec(1, admd, regi);								}								opsize = 0;								argn = 2;							} else {								invalidopcode();							}										break;								}								break;							case 2:								/* Opcode = 0100111010mmmrrr */								PStrCopy(op, (StringPtr)"\pJsr");								opsize = 0;								adec(0, decodeone_Env.mode,									decodeone_Env.reg);								argn = 1;								break;							case 3:								/* Opcode = 0100111011mmmrrr */								PStrCopy(op, (StringPtr)"\pJmp");								opsize = 0;								adec(0, decodeone_Env.mode,									decodeone_Env.reg);								argn = 1;								break;						}						break;				}			}			break;		case 5:			/* Opcode = 5xxx */			if (decodeone_Env.b76 == 3) {				if (decodeone_Env.mode == 1) {					concod((StringPtr)"\pDB", &decodeone_Env);						/* Opcode = 0101cccc11001ddd */					opsize = 2;					adec(0, 0, decodeone_Env.reg);					adec(1, 7, 2);					argn = 2;				} else {					concod((StringPtr)"\pS", &decodeone_Env);						/* Opcode = 0101cccc11mmmrrr */					opsize = 1;					adec(0, decodeone_Env.mode, decodeone_Env.reg);					argn = 1;				}			} else {				if (decodeone_Env.b8 == 0) {					PStrCopy(op, (StringPtr)"\pAddQ");						/* Opcode = 0101nnn0ssmmmrrr */				} else {					PStrCopy(op, (StringPtr)"\pSubQ");						/* Opcode = 0101nnn1ssmmmrrr */				}				opsize = 0;				/* opsize = decodeone_Env.b8 * 2 + 2; */				adec(0, 8, octdat(decodeone_Env.rg9));				adec(1, decodeone_Env.mode, decodeone_Env.reg);				switch (decodeone_Env.b76) {					case 0:						opsize = 1;						break;					case 1:						opsize = 2;						break;					case 2:					default:						opsize = 4;						break;				}				argn = 2;			}			break;		case 6:			/* Opcode = 6xxx */			if (by2 == 0) {				opsize = 2;			} else if (by2 == 255) {				opsize = 4;			} else {				opsize = 1;			}			if (decodeone_Env.cond == 1) {				PStrCopy(op, (StringPtr)"\pBsr");					/* Opcode = 01100001nnnnnnnn */				adec(0, 9, extb(by2));				argn = 1;			} else {				if (decodeone_Env.cond == 0) {					PStrCopy(op, (StringPtr)"\pBra");						/* Opcode = 01100000nnnnnnnn */				} else {					concod((StringPtr)"\pB", &decodeone_Env);				}				adec(0, 9, extb(by2));					/* Opcode = 0110ccccnnnnnnnn */				argn = 1;			}			break;		case 7:			PStrCopy(op, (StringPtr)"\pMoveQ");				/* Opcode = 0111ddd0nnnnnnnn */			opsize = 4;			adec(0, 8, extb(by2));			adec(1, 0, decodeone_Env.rg9);			argn = 2;			break;		case 8:			/* Opcode = 8xxx */			if (decodeone_Env.b76 == 3) {				if (decodeone_Env.b8 == 0) {					/* Opcode = 1000ddd011mmmrrr */					PStrCopy(op, (StringPtr)"\pDivU");				} else {					/* Opcode = 1000ddd111mmmrrr */					PStrCopy(op, (StringPtr)"\pDivS");				}				opsize = 2;				adec(0, decodeone_Env.mode, decodeone_Env.reg);				adec(1, 0, decodeone_Env.rg9);				argn = 2;			} else if (decodeone_Env.b8 == 1 && decodeone_Env.mode < 2)			{				PStrCopy(op, (StringPtr)"\pSbcd");					/* Opcode = 1000xxx10000mxxx */				opsize = 1;				blahcode(&decodeone_Env);			} else {				PStrCopy(op, (StringPtr)"\pOr");					/* Opcode = 1000dddmssmmmrrr */				findsize(&decodeone_Env);				argn = 2;				if (decodeone_Env.b8 == 1) {					adec(0, 0, decodeone_Env.rg9);					adec(1, decodeone_Env.mode, decodeone_Env.reg);				} else {					adec(0, decodeone_Env.mode, decodeone_Env.reg);					adec(1, 0, decodeone_Env.rg9);				}			}			break;		case 9:		case 13:			argn = 2;			findsize(&decodeone_Env);			if (nib1 == 13) {				PStrCopy(op, (StringPtr)"\pAdd");					/* Opcode = 1101dddmssmmmrrr */			} else {				PStrCopy(op, (StringPtr)"\pSub");					/* Opcode = 1001dddmssmmmrrr */			}			if (decodeone_Env.b76 == 3) {				PStrAppend(op, (StringPtr)"\pA");				opsize = decodeone_Env.b8 * 2 + 2;				adec(0, decodeone_Env.mode, decodeone_Env.reg);				adec(1, 1, decodeone_Env.rg9);			} else if (decodeone_Env.b8 == 0) {				adec(0, decodeone_Env.mode, decodeone_Env.reg);				adec(1, 0, decodeone_Env.rg9);			} else if (decodeone_Env.mode < 2) {				PStrAppend(op, (StringPtr)"\pX");				blahcode(&decodeone_Env);			} else {				adec(0, 0, decodeone_Env.rg9);				adec(1, decodeone_Env.mode, decodeone_Env.reg);			}			break;		case 10:			/* Opcode = Axxx */			aline(by1, by2);			break;		case 11:			/* Opcode = Bxxx */			if (decodeone_Env.b76 == 3) {				PStrCopy(op, (StringPtr)"\pCmpA");					/* Opcode = 1011ddds11mmmrrr */				opsize = decodeone_Env.b8 * 2 + 2;				argn = 2;				adec(0, decodeone_Env.mode, decodeone_Env.reg);				adec(1, 1, decodeone_Env.rg9);			} else if (decodeone_Env.b8 == 1 && decodeone_Env.mode == 1)			{				PStrCopy(op, (StringPtr)"\pCmpM");					/* Opcode = 1011ddd1ss001rrr */				findsize(&decodeone_Env);				argn = 2;				adec(0, 3, decodeone_Env.reg);				adec(1, 3, decodeone_Env.rg9);			} else if (decodeone_Env.b8 == 1) {				PStrCopy(op, (StringPtr)"\pEor");					/* Opcode = 1011ddd1ssmmmrrr */				findsize(&decodeone_Env);				argn = 2;				adec(0, 0, decodeone_Env.rg9);				adec(1, decodeone_Env.mode, decodeone_Env.reg);			} else {				PStrCopy(op, (StringPtr)"\pCmp");					/* Opcode = 1011ddd0ssmmmrrr */				findsize(&decodeone_Env);				argn = 2;				adec(0, decodeone_Env.mode, decodeone_Env.reg);				adec(1, 0, decodeone_Env.rg9);			}			break;		case 12:			/* Opcode = Cxxx */			if (decodeone_Env.b76 == 3) {				if (decodeone_Env.b8 == 0) {					PStrCopy(op, (StringPtr)"\pMulU");						/* Opcode = 1100ddd011mmmrrr */				} else {					PStrCopy(op, (StringPtr)"\pMulS");						/* Opcode = 1100ddd111mmmrrr */				}				opsize = 2;				argn = 2;				adec(0, decodeone_Env.mode, decodeone_Env.reg);				adec(1, 0, decodeone_Env.rg9);			} else if ((decodeone_Env.mode < 2)				&& (decodeone_Env.b8 == 1))			{				switch (decodeone_Env.b76) {					case 0:						PStrCopy(op, (StringPtr)"\pAbcd");							/* Opcode = 1100ddd10000mrrr */						opsize = 1;						blahcode(&decodeone_Env);						break;					case 1:						PStrCopy(op, (StringPtr)"\pExg");							/* Opcode = 1100ddd10100trrr */						opsize = 4;						argn = 2;						adec(0, decodeone_Env.mode, decodeone_Env.rg9);						adec(1, decodeone_Env.mode, decodeone_Env.reg);						break;					case 2:						PStrCopy(op, (StringPtr)"\pExg");							/* Opcode = 1100ddd110001rrr */						opsize = 4;						argn = 2;						adec(0, 0, decodeone_Env.rg9);						adec(1, 1, decodeone_Env.reg);						break;				}			} else {				PStrCopy(op, (StringPtr)"\pAnd");					/* Opcode = 1100dddmssmmmrrr */				findsize(&decodeone_Env);				argn = 2;				if (decodeone_Env.b8 == 1) {					adec(0, 0, decodeone_Env.rg9);					adec(1, decodeone_Env.mode, decodeone_Env.reg);				} else {					adec(0, decodeone_Env.mode, decodeone_Env.reg);					adec(1, 0, decodeone_Env.rg9);				}			}			break;		case 14:			/* Opcode = Exxx */			if (decodeone_Env.b76 == 3) {				if ((opcode & 0x0800) != 0) {					ui4r extra = prgin_readWord();					switch ((opcode >> 8) & 7) {						case 0: /* BFTST */							PStrCopy(op, (StringPtr)"\pBFTST");							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							argn = 1;							break;						case 1: /* BFEXTU */							PStrCopy(op, (StringPtr)"\pBFEXTU");							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							adec(1, 0, (extra >> 12) & 7);							argn = 2;							break;						case 2: /* BFCHG */							PStrCopy(op, (StringPtr)"\pBFCHG");							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							argn = 1;							break;						case 3: /* BFEXTS */							PStrCopy(op, (StringPtr)"\pBFEXTS");							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							adec(1, 0, (extra >> 12) & 7);							argn = 2;							break;						case 4: /* BFCLR */							PStrCopy(op, (StringPtr)"\pBFCLR");							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							argn = 1;							break;						case 5: /* BFFFO */							PStrCopy(op, (StringPtr)"\pBFFFO");							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							adec(1, 0, (extra >> 12) & 7);							argn = 2;							break;						case 6: /* BFSET */							PStrCopy(op, (StringPtr)"\pBFSET");							adec(0, decodeone_Env.mode,								decodeone_Env.reg);							argn = 1;							break;						case 7: /* BFINS */							PStrCopy(op, (StringPtr)"\pBFINS");							adec(0, 0, (extra >> 12) & 7);							adec(1, decodeone_Env.mode,								decodeone_Env.reg);							argn = 2;							break;					}					PStrAppend(op, (StringPtr)"\p {");					if ((extra & 0x0800) != 0) {						PStrApndChar(op, 'D');						PStrApndChar(op, hexdv[(extra >> 6) & 7]);					} else {						PStrApndUimrCnst2Hex(op, (extra >> 6) & 0x1f);					}					PStrApndChar(op, ':');					if ((extra & 0x0020) != 0) {						PStrApndChar(op, 'D');						PStrApndChar(op, hexdv[(extra >> 6) & 7]);					} else {						PStrApndUimrCnst2Hex(op,							((extra - 1) & 0x001F) + 1);					}					PStrApndChar(op, '}');				} else {					rolops(decodeone_Env.rg9, &decodeone_Env);						/* Opcode = 11100tt111mmmrrr */					opsize = 2;					argn = 1;					adec(0, decodeone_Env.mode, decodeone_Env.reg);				}			} else {				rolops(BitAnd(decodeone_Env.mode, 3), &decodeone_Env);				findsize(&decodeone_Env);				argn = 2;				if (decodeone_Env.mode < 4) {					/* Opcode = 1110cccdss0ttddd */					adec(0, 8, octdat(decodeone_Env.rg9));				} else {					/* Opcode = 1110rrrdss1ttddd */					adec(0, 0, decodeone_Env.rg9);				}				adec(1, 0, decodeone_Env.reg);			}			break;		case 15:			/* Opcode = Fxxx */			if (0 == (opcode & 0x0FC0)) {				/*					Decode selected MMU instructions.					By Rob					"I believe I have correctly implemented the pmove,					pload, and pflush family of instructions for the					68851 and 68030 for fdisasm.  At least, I've					verified the IIsi ROM's use of the instructions					for invalidating caches, swapping between 24 and					32bit addressing modes, and through setting up the					MMU mappings for slot information."				*/				ui4r opcode2 = prgin_readWord();				ui3r preg = (opcode2 >> 10) & 7;				ui3r direction = (opcode2 >> 9) & 1;				ui3r pcode = (opcode2 >> 13) & 7;				ui3r pmode = preg;				ui3r pmask = (opcode2 & 0x01E0) >> 5;				ui3r pfc = (opcode2 & 0x001F);				/* Opcode = 1111000000mmmaaa */				switch(pcode) {					case 0:						opsize = 0;						argn = 2;						if (0 != ((opcode >> 8) & 1)) {							PStrCopy(op, (StringPtr)"\pPMoveFD");						} else {							PStrCopy(op, (StringPtr)"\pPMove");						}						adec(direction, decodeone_Env.mode,							decodeone_Env.reg);						switch(preg) {							case 2:								PStrCopy(arg[! direction],									(StringPtr)"\pTT0");								break;							case 3:								PStrCopy(arg[! direction],									(StringPtr)"\pTT1");								break;							default:								PStrCopy(arg[! direction],									(StringPtr)									"\pUnknown Access Control Register"									);								break;						};						break;					case 1:						opsize = 0;						if (pmode == 0) {							argn = 2;							if (direction) {								PStrCopy(op, (StringPtr)"\pPLoadR");							} else {								PStrCopy(op, (StringPtr)"\pPLoadW");							}							PStrClear(arg[0]);							PStrApndUimrCnst2Hex(arg[0], pfc & 0xF);							adec(1, decodeone_Env.mode,								decodeone_Env.reg);						} else if (pmode == 1) {							argn = 0;							PStrCopy(op, (StringPtr)"\pPFlushA");						} else if (0 != (pmode & 4)) {							argn = 1;							if (pmode & 1) {								PStrCopy(op, (StringPtr)"\pPFlush");							} else {								PStrCopy(op, (StringPtr)"\pPFlushS");							}							if (pfc & 0x0010) {								PStrClear(arg[0]);								PStrApndUimrCnst2Hex(arg[0],									(pfc & 0xF));							} else if ((pfc & 0x0018) == 0x00080) {								PStrCopy(arg[0], (StringPtr)"\pD");								PStrApndChar(arg[0], hexdv[(pfc & 7)]);							} else if (pfc == 0) {								PStrCopy(arg[0], (StringPtr)"\pSFC");							} else if (pfc == 1) {								PStrCopy(arg[0], (StringPtr)"\pDFC");							}							PStrAppend(arg[0], (StringPtr)"\p, ");							PStrApndUimrCnst2Hex(arg[0], pmask);							if (pmode & 2) {								argn = 2;								adec(1, decodeone_Env.mode,									decodeone_Env.reg);							}						}						break;					case 2:						opsize = 0;						argn = 2;						if ((opcode2 >> 8) & 1) {							PStrCopy(op, (StringPtr)"\pPMoveFD");						} else {							PStrCopy(op, (StringPtr)"\pPMove");						}						adec(direction, decodeone_Env.mode,							decodeone_Env.reg);						switch(preg) {							case 0:								PStrCopy(arg[! direction],									(StringPtr)"\pTC");								break;							case 1:								PStrCopy(arg[! direction],									(StringPtr)"\pDRP");								break;							case 2:								PStrCopy(arg[! direction],									(StringPtr)"\pSR");								break;							case 3:								PStrCopy(arg[! direction],									(StringPtr)"\pCRP");								break;							case 4:								PStrCopy(arg[! direction],									(StringPtr)"\pCA");								break;							case 6:								PStrCopy(arg[! direction],									(StringPtr)"\pSC");								break;							case 7:								PStrCopy(arg[! direction],									(StringPtr)"\pAC");								break;							default:								PStrCopy(arg[! direction],									(StringPtr)"\pUnknown MMU Register"									);								break;						};						break;					case 3:						opsize = 0;						argn = 2;						PStrCopy(op, (StringPtr)"\pPMove");						adec(direction, decodeone_Env.mode,							decodeone_Env.reg);						switch(preg) {							case 0:								PStrCopy(arg[! direction],									(StringPtr)"\pACUSR");								break;							case 4:								PStrCopy(arg[! direction],									(StringPtr)"\pBAD");								PStrApndUimr2Hex(arg[! direction],									(opcode2 >> 2) & 7);								break;							case 5:								PStrCopy(arg[! direction],									(StringPtr)"\pBAC");								PStrApndUimr2Hex(arg[! direction],									(opcode2 >> 2) & 7);								break;							default:								PStrCopy(arg[! direction],									(StringPtr)"\pUnknown Register");								break;						};						break;					case 5:						PStrCopy(op, (StringPtr)"\pPFlushR");						adec(0, decodeone_Env.mode, decodeone_Env.reg);						argn = 1;						break;					default:						invalidopcode();						break;				}			} else {				invalidopcode();			}			break;	}	endinstruction();}/* -- disemformat -- */LOCALVAR uimr EndNext;LOCALFUNC blnr disem_CheckAbort(void){	ProgressBarVal = prgin_i;	return ! CheckSysErr(CheckAbortRequested());}LOCALFUNC blnr probeaddr(void){	if (decoding_code) {		while (prgin_i < EndNext) {			decodeone();			if (disem_CheckAbort()) {				return falseblnr;			}		}	} else {		switch (decodemode) {			case decodemode_kUnknown:				{					int n;					int i;					MyPStr t;					while (prgin_i < EndNext) {						begininstruction();						opsize = 0;						PStrCopy(arg[0], (StringPtr)"\p$");						n = EndNext - prgin_i;						if ((n >= 4) && (0 == (prgin_i & 3))) {							PStrCopy(op, (StringPtr)"\pDC.L");							longhex(prgin_readLong(), t);						} else if ((n >= 2) && (0 == (prgin_i & 1))) {							PStrCopy(op, (StringPtr)"\pDC.W");							wordhex(prgin_readWord(), t);						} else {							PStrCopy(op, (StringPtr)"\pDC.B");							bytehex(prgin_readByte(), t);						}						PStrAppend(arg[0], t);						PStrCopy(remark, (StringPtr)"\p'");						for (i = 0; i < linbufi; ++i) {							MyCharR y = linbufa[i];							if ('\'' == y) {								PStrAppend(remark, (StringPtr)"\p''");							} else {								if (y < 32 || y > 126) {									y = ' ';								}								PStrApndChar(remark, y);							}						}						PStrAppend(remark, (StringPtr)"\p'");						isremark = true;						argn = 1;						endinstruction();						if (disem_CheckAbort()) {							return falseblnr;						}					}				}				break;			case decodemode_kData:				{					while (prgin_i < EndNext) {						begininstruction();						{							MyPStr t;							opsize = 0;							switch (decodemodedatsize) {								case 1:									PStrCopy(op, (StringPtr)"\pDC.B");									bytehex(prgin_readByte(), t);									break;								case 2:									PStrCopy(op, (StringPtr)"\pDC.W");									wordhex(prgin_readWord(), t);									break;								case 4:									PStrCopy(op, (StringPtr)"\pDC.L");									longhex(prgin_readLong(), t);									break;							}							PStrCopy(arg[0], (StringPtr)"\p$");							PStrAppend(arg[0], t);							argn = 1;						}						endinstruction();						if (disem_CheckAbort()) {							return falseblnr;						}					}				}				break;		}	}	return trueblnr;}LOCALFUNC blnr getflag(blnr *v){	blnr IsOk = falseblnr;	token_advance(); /* skip over name */	if (token_kEof == token_kind) {		MyAlertFromCStr("Unexpected end of format file.");	} else {		if (PStrEq(token_peek, (StringPtr)"\p+")) {			token_advance();			*v = trueblnr;			IsOk = trueblnr;		} else if (PStrEq(token_peek, (StringPtr)"\p-")) {			token_advance();			*v = falseblnr;			IsOk = trueblnr;		} else {			MyAlertFromCStr("expecting '+' or '-' in format file.");		}	}	return IsOk;}LOCALFUNC blnr parseinteger(uimr *i){	blnr IsOk = falseblnr;	if (token_kEof == token_kind) {		MyAlertFromCStr("Unexpected end of format file.");	} else if (! token_isHexNumber()) {		MyAlertFromCStr("expecting a number in format file.");	} else {		*i = token_getHex2Uimr();		IsOk = trueblnr;	}	return IsOk;}LOCALFUNC blnr getnum(short *v){	uimr i;	blnr IsOk = falseblnr;	token_advance();	if (parseinteger(&i)) {		*v = i;		IsOk = trueblnr;	}	return IsOk;}LOCALVAR uimr FormatNext = 0;LOCALFUNC blnr parsenextaddress(void){	uimr next;	blnr IsOk = falseblnr;	token_advance();	if (! parseinteger(&next)) {	} else if ((next < FormatNext) && (0 != FormatNext)) {		MyAlertFromCStr("Format not ascending.");	} else {		FormatNext = next;		IsOk = trueblnr;	}	return IsOk;}LOCALFUNC blnr do_switch(void){	blnr IsOk = falseblnr;	switch (PStrLength(token_peek)) {		case 1:			switch (token_peek[1]) {				case '.':					IsOk = parsenextaddress();					break;				case '&':					token_advance();					if (decodemode_kData != decodemode) {						MyAlertFromCStr("'&' only works with data.");					} else {						FormatNext += decodemodedatsize;						IsOk = trueblnr;					}					break;				case 'B':					token_advance();					decodemode = decodemode_kData;					decodemodedatsize = 1;					IsOk = trueblnr;					break;				case 'W':					token_advance();					decodemode = decodemode_kData;					decodemodedatsize = 2;					IsOk = trueblnr;					break;				case 'L':					token_advance();					decodemode = decodemode_kData;					decodemodedatsize = 4;					IsOk = trueblnr;					break;				case '?':					token_advance();					decodemode = decodemode_kUnknown;					IsOk = trueblnr;					break;				case 'A':					IsOk = getflag(&doaddr);					break;				case 'H':					IsOk = getflag(&dohex);					break;				case 'R':					IsOk = getflag(&dorem);					break;#if 0				case 'W':					IsOk = getnum(&words);					break;#endif				case 'Z':					IsOk = getnum(&glsize);					break;				case 'I':					IsOk = getnum(&indntc);					break;				case '!':					token_advance();					BeginWriteInLabelField();					strmo_writePStr((StringPtr)"\p; ");					strmo_writePStr(token_peek);					strmo_writeReturn();					token_advance();					IsOk = trueblnr;					break;				case ';':					token_advance();					PStrCopy(remark, token_peek);					isremark = true;					token_advance();					IsOk = trueblnr;					break;				case 'N':					token_advance();					if (islabel) {						WriteLabelLine();					} else {						strmo_writeln(							(StringPtr)"\p; !! Spurious P in format");					}					IsOk = trueblnr;					break;				case 'S':					token_advance();					strmo_writeReturn();					IsOk = trueblnr;					break;				case 'P':					token_advance();					if (islabel) {						strmo_writeReturn();						WriteLabelLine();					} else {						strmo_writeln(							(StringPtr)"\p; !! Spurious P in format");					}					IsOk = trueblnr;					break;				default:					MyAlertFromCStr("unknown switch in format");					break;			}			break;		default:			MyAlertFromCStr("unknown switch in format");			break;	}	return IsOk;}LOCALFUNC blnr Format_GetNext(void){	blnr IsOk = falseblnr;label_retry:	if (FormatNext > prgin_i) {		if (FormatNext < EndNext) {			EndNext = FormatNext;		}		IsOk = trueblnr;	} else if (token_kEof == token_kind) {		/* done */		IsOk = trueblnr;	} else if (disem_CheckAbort()) {		/* done */	} else if (do_switch()) {		goto label_retry;	}	return IsOk;}/* -- DisemSet -- */LOCALFUNC blnr sym_nextsymbol(void){	blnr IsOk = falseblnr;label_retry:	if (sym_iterDone) {		IsOk = trueblnr;	} else if (sym_iterAddr > prgin_i) {		if (sym_iterAddr < EndNext) {			EndNext = sym_iterAddr;		}		IsOk = trueblnr;	} else if (disem_CheckAbort()) {	} else {		sym_get(sym_iterS, lbl);		if (sym_iterAddr == prgin_i) {			islabel = true;		} else {			/* sym_iterAddr < prgin_i, missed this one */			strmo_writePStr(lbl);			strmo_writePStr((StringPtr)"\p EQU * - $");			strmo_Simr2Hex(prgin_i - sym_iterAddr);			strmo_writeReturn();		}		sym_iterNext();		goto label_retry;	}	return IsOk;}LOCALFUNC blnr binmap_nextsymbol(void){	blnr IsOk = falseblnr;label_retry:	if (binmap_iterDone) {		IsOk = trueblnr;	} else if (binmap_iterAddr > prgin_i) {		if (binmap_iterAddr < EndNext) {			EndNext = binmap_iterAddr;		}		IsOk = trueblnr;	} else if (disem_CheckAbort()) {	} else {		if (binmap_kIsCode == binmap_iterKind) {			decoding_code = trueblnr;		} else {			if (decoding_code) {				decoding_code = falseblnr;				decodemode = decodemode_kUnknown;			}		}		binmap_iterNext();		goto label_retry;	}	return IsOk;}LOCALPROC ProgramMain(void){	vCheckSysErr(		ProgressBar_SetStage_v2("Disassembling\311", prgin_Mx));	sym_iterBegin(sym_kTableRel);	binmap_iterBegin();label_retry:	EndNext = prgin_Mx;	if (sym_nextsymbol())	if (binmap_nextsymbol())	if (Format_GetNext())	if (prgin_i < prgin_Mx)	if (probeaddr())	{		goto label_retry;	}}LOCALPROC ProgramZapVars(void){	dis_zap();}LOCALPROC ProgramPreInit(void){	OneWindAppPreInit();}LOCALFUNC blnr ProgramInit(void){	MyDir_R BaseDirR;	if (CheckSysErr(MyMemory_Init_v2()))	if (CheckSysErr(OneWindAppInit_v2()))	if (CheckSysErr(MyHGetDir_v2(&BaseDirR)))	if (CheckSysErr(prgin_open_v2(&BaseDirR, (StringPtr)"\pbin")))	if (CheckSysErr(binmap_load_v2(&BaseDirR, (StringPtr)"\pbin_map")))	if (CheckSysErr(sym_load_v2(&BaseDirR)))	if (CheckSysErr(token_open_v2(&BaseDirR,		(StringPtr)"\pformat", nullpr)))	if (CheckSysErr(strmo_open_v2(&BaseDirR, (StringPtr)"\plisting")))	{		return trueblnr;	}	return falseblnr;}LOCALPROC ProgramUnInit(void){	vCheckSysErr(strmo_close_v2());	vCheckSysErr(token_close_v2());	sym_dispose();	binmap_dispose();	vCheckSysErr(prgin_close_v2());	OneWindAppUnInit();	MyMemory_UnInit();}int main(void){	ProgramZapVars();	ProgramPreInit();	if (ProgramInit()) {		ProgramMain();	}	ProgramUnInit();	return 0;}