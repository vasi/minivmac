/*	REFERMAX.i	Copyright (C) 2008 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	REFERerence MAXimum*/LOCALVAR uimr ref_n = 0;LOCALVAR uimr ref_alloc = 0;LOCALVAR ui5h ref_addr = nullpr;LOCALVAR ui4h ref_kind = nullpr;LOCALPROC ref_dispose(void){	MyNHandleClear((Handle *)&ref_addr);	MyNHandleClear((Handle *)&ref_kind);	ref_n = 0;	ref_alloc = 0;}LOCALPROC ref_clear(void){	ref_n = 0;}LOCALFUNC tMyErr ref_SetSize_v2(uimr ref_newalloc){	tMyErr err;	if (noErr == (err = MyNHandleSetLen_v2((Handle *)&ref_addr, ref_newalloc * sizeof(uimr))))	if (noErr == (err = MyNHandleSetLen_v2((Handle *)&ref_kind, ref_newalloc * sizeof(ui4b))))	{		/* ok */	}	return err;}LOCALFUNC tMyErr ref_SetMinAlloc_v2(uimr ref_minalloc){	tMyErr err;	uimr ref_newalloc = CeilPowerOf2(ref_minalloc);	if (ref_newalloc == ref_alloc) {		err = noErr;	} else {		if (noErr != (err = ref_SetSize_v2(ref_newalloc))) {			if (ref_newalloc > ref_alloc) {				(void) ref_SetSize_v2(ref_alloc);					/* ignore any error, since already got one */				goto error_exit;			}		}		ref_alloc = ref_newalloc;	}error_exit:	return err;}LOCALFUNC tMyErr ref_insertat_v2(uimr j, uimr addr, ui4r what){	tMyErr err;	uimr i;	uimr ref_newn = ref_n + 1;	if (ref_newn > ref_alloc) {		err = ref_SetMinAlloc_v2(ref_newn);		if (noErr != err) {			return err;		}	}	/* make room */	i = ref_n;	while (i > j) {		(*ref_addr)[i] = (*ref_addr)[i - 1];		(*ref_kind)[i] = (*ref_kind)[i - 1];		--i;	}	/* insert */	(*ref_addr)[j]  = addr;	(*ref_kind)[j]  = what;	ref_n = ref_newn;	return noErr;}GLOBALFUNC tMyErr ref_add_v2(uimr addr, ui4r what){	tMyErr err;	uimr j;	uimr jv;	j = ref_n;label_retry:	if (0 == j) {		err = ref_insertat_v2(0, addr, what);	} else {		--j;		jv = (*ref_addr)[j];		if (jv > addr) {			goto label_retry;		} else if (jv != addr) {			err = ref_insertat_v2(j + 1, addr, what);		} else {			if (what > (*ref_kind)[j]) {				(*ref_kind)[j] = what;			}			err = noErr;		}	}	return err;}