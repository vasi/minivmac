/*	TOKENIZR.i	Copyright (C) 2008 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	TOKENIZeR*/#define token_kEof 0#define token_kTok 1#define token_kQuo 2LOCALVAR ui4r token_kind;LOCALVAR Str255 token_peek;LOCALFUNC int IsSpaceChar(char x){	switch (x) {		case ' ':		case (char)13:			return true;		default:			return false;	}}LOCALFUNC int IsSymbolChar(char x){	return ((x >= 'a') && (x <= 'z'))		|| ((x >= 'A') && (x <= 'Z'))		|| ((x >= '0') && (x <= '9'));}#define quotechar '\"'LOCALPROC token_advance(void){label_retry:	if (! strmi_neof) {		token_kind = token_kEof;	} else if (IsSpaceChar(strmi_peek)) {		strmi_advance();		goto label_retry;	} else if (strmi_peek == quotechar) {		strmi_advance();		PStrClear(token_peek);		while (strmi_neof && (strmi_peek != quotechar)) {			PStrApndChar(token_peek, strmi_peek);			strmi_advance();		}		strmi_advance();		token_kind = token_kTok;	} else if (IsSymbolChar(strmi_peek)) {		PStrClear(token_peek);		do {			PStrApndChar(token_peek, strmi_peek);			strmi_advance();		} while (strmi_neof && IsSymbolChar(strmi_peek));		token_kind = token_kQuo;	} else {		PStrFromChar(token_peek, strmi_peek);		strmi_advance();		token_kind = token_kTok;	}}GLOBALFUNC tMyErr token_open_v2(MyDir_R *d, ps3p s, blnr *foundit){	tMyErr err;	if (noErr == (err = strmi_open_v2(d, s, foundit))) {		token_advance();	}	return err;}#define token_close_v2 strmi_close_v2LOCALFUNC blnr token_isNumber(void){	si4r i;	MyCharR c1;	MyCharPtr p = token_peek;	MyCharR n = *p++;	for (i = n; --i >= 0; ) {		c1 = *p++;		if (! ((c1 >= '0') && (c1 <= '9'))) {			return falseblnr;		}	}	return trueblnr;}LOCALFUNC uimr token_val(void){	uimr v;	short i;	short n;	v = 0;	n = PStrLength(token_peek);	for (i = 1; i <= n; ++i) {		v = v * 10 + token_peek[i] - '0';	}	return v;}LOCALFUNC uimr token_getNumber(void){	uimr v = token_val();	token_advance();	return v;}LOCALFUNC blnr token_isHexNumber(void){	/* assuming token_kind != token_kEof */	return PStrIsHexNumber(token_peek);}LOCALFUNC uimr token_getHex2Uimr(void){	/* assuming token_isHexNumber */	uimr v = Hex2Uimr(token_peek);	token_advance();	return v;}