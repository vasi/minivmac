/*	DEBUGLOG.i	Copyright (C) 2008 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	DEBUGging LOG to Text file*/LOCALVAR short dbglog_bufref = NotAfileRef;LOCALVAR Handle dbglog_bufh = nullpr;LOCALVAR tMyErr dbglog_err = noErr;#define dbglog_buflnsz 14#define dbglog_bufsz PowOf2(dbglog_buflnsz)LOCALVAR uimr dbglog_bufpos;LOCALPROC dbglog_write0(MyPtr p, uimr L){	if (noErr == dbglog_err) {		dbglog_err = MyWriteBytes_v2(dbglog_bufref, p, L);	}}GLOBALFUNC tMyErr dbglog_close(void){	tMyErr err = dbglog_err;	dbglog_err = noErr;	if (NotAfileRef != dbglog_bufref) {		if (nullpr != dbglog_bufh) {			uimr n = ModPow2(dbglog_bufpos, dbglog_buflnsz);			if (n != 0) {				dbglog_write0((MyPtr)*dbglog_bufh, n);			}			DisposeHandle(dbglog_bufh);			err = CombineErr(err, SetEOF(dbglog_bufref, (long)dbglog_bufpos));			dbglog_bufh = nullpr;		}		err = CombineErr(err, MyCloseFile_v2(dbglog_bufref));		dbglog_bufref = NotAfileRef;	}	return err;}GLOBALFUNC tMyErr dbglog_open(void){	tMyErr err;	MyDir_R d;	if (noErr == (err = MyHGetDir_v2(&d))) {		err = MyFileOpen_v2(&d, (StringPtr)"\pdbglog",				(char)fsWrPerm, &dbglog_bufref);		if (fnfErr == err) {			err = MyOpenNewFile_v2(&d, (StringPtr)"\pdbglog",				'MPS ', 'TEXT', &dbglog_bufref);		}		if (noErr == err) {			dbglog_bufh = NewHandle(dbglog_bufsz);			if (NULL == dbglog_bufh) {				err = MemError();				if (noErr == err) {					err = kMyErrSysUnknown;				}			} else {				dbglog_bufpos = 0;			}		}		if (noErr != err) {			(void) dbglog_close();				/* ignore any error, since already got one */		}	}	return err;}LOCALPROC dbglog_writeByte(ui3r v){	uimr bufposmod = ModPow2(dbglog_bufpos, dbglog_buflnsz);	((ui3p)*dbglog_bufh)[bufposmod] = v;	if (ModPow2(bufposmod + 1, dbglog_buflnsz) == 0) {		dbglog_write0((MyPtr)*dbglog_bufh, dbglog_bufsz);	}	++dbglog_bufpos;}LOCALPROC dbglog_write(MyPtr p, uimr L){	uimr r;	uimr bufposmod;	uimr curbufdiv;	uimr newbufpos = dbglog_bufpos + L;	uimr newbufdiv = FloorDivPow2(newbufpos, dbglog_buflnsz);label_retry:	curbufdiv = FloorDivPow2(dbglog_bufpos, dbglog_buflnsz);	bufposmod = ModPow2(dbglog_bufpos, dbglog_buflnsz);	if (newbufdiv != curbufdiv) {		r = dbglog_bufsz - bufposmod;		MyMoveBytes(p, (MyPtr)*dbglog_bufh + bufposmod, r);		dbglog_write0((MyPtr)*dbglog_bufh, dbglog_bufsz);		L -= r;		p += r;		dbglog_bufpos += r;		goto label_retry;	}	MyMoveBytes(p, (MyPtr)*dbglog_bufh + bufposmod, L);	dbglog_bufpos = newbufpos;}LOCALPROC dbglog_writePStr(ps3p s){	dbglog_write(PStrToPtr(s), PStrToSize(s));}LOCALPROC dbglog_writeCStr(char *s){	dbglog_write((MyPtr)s, CStrLength(s));}LOCALPROC dbglog_writeReturn(void){	dbglog_writeByte(13);}#define dbglog_writeChar(x) dbglog_writeByte((ui3r)(x))LOCALPROC dbglog_writeNum(simr v){	MyPStr s;	NumToString(v, s);	dbglog_writePStr(s);}LOCALPROC dbglog_writeSpace(void){	dbglog_writeChar(' ');}LOCALPROC dbglog_writeln(char *s){	dbglog_writeCStr(s);	dbglog_writeReturn();}LOCALPROC dbglog_writelnNum(char *s, simr v){	dbglog_writeCStr(s);	dbglog_writeSpace();	dbglog_writeNum(v);	dbglog_writeReturn();}#define Have_DEBUGLOG 1