/*	PRIQUEUE.i	Copyright (C) 2008 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	PRIority QUEUE	Efficiently find and remove the miminum value entry	of those so far added. By default works with type	uimr, but the type and comparison function	may be redefined at compile time.	This can be used for sorting (i.e. first adding all	entries, and then removing all, not taking advantage of the	ability to intersperse). It's not the fastest sort, but	it's not too bad, and has better worse case behavior than	quicksort.*/#ifndef prq_vr#define prq_vr uimr#endif#ifndef prq_lt#define prq_lt(x, y) ((x) < (y))#endiftypedef prq_vr *prq_pVc;typedef prq_pVc *prq_hVc;typedef uimr prq_node;static uimr prq_n = 0;static uimr prq_alloc = 0;static prq_hVc prq_h = nullpr;LOCALPROC prq_dispose(void){	prq_n = 0;	prq_alloc = 0;	MyNHandleClear((Handle *)&prq_h);}LOCALPROC prq_makenull(void){	prq_n = 0;}LOCALFUNC Boolean prq_empty(void){	return 0 == prq_n;}LOCALPROC prq_floatup(prq_node q, prq_vr qv){	prq_node u;	prq_vr uv;label_retry:	if (0 != q) {		u = (q - 1) / 2;		uv = (prq_vr)(*prq_h)[u];		if (prq_lt(qv, uv)) {			(*prq_h)[q] = (uimr)uv;			q = u;			goto label_retry;		}	}	(*prq_h)[q] = (uimr)qv;}LOCALPROC prq_floatdown(prq_node q, prq_vr qv){	prq_node dl;	prq_node dr;	prq_vr dlv;	prq_vr drv;label_retry:	dl = 2 * q + 1;	dr = dl + 1;	if (dr < prq_n) {		dlv = (prq_vr)(*prq_h)[dl];		drv = (prq_vr)(*prq_h)[dr];		if (prq_lt(dlv, drv)) {label_tryleft:			if (prq_lt(dlv, qv)) {				(*prq_h)[q] = (uimr)dlv;				q = dl;				goto label_retry;			}		} else {			if (prq_lt(drv, qv)) {				(*prq_h)[q] = (uimr)drv;				q = dr;				goto label_retry;			}		}	} else if (dl < prq_n) {		dlv = (prq_vr)(*prq_h)[dl];		goto label_tryleft;	}	(*prq_h)[q] = (uimr)qv;}LOCALFUNC blnr prq_deletemin(prq_vr *v){	blnr IsOk = falseblnr;	if (0 != prq_n) {		prq_node prq_newn = prq_n - 1;		prq_vr lastv = (prq_vr)(*prq_h)[prq_newn];		prq_n = prq_newn;		*v = (prq_vr)(*prq_h)[0];		prq_floatdown(0, lastv);		IsOk = trueblnr;	}	return IsOk;}LOCALFUNC tMyErr prq_IncreaseMinAlloc_v2(uimr prq_minalloc){	tMyErr err;	uimr prq_newalloc;	prq_newalloc = CeilPowerOf2(prq_minalloc);	if (noErr == (err = MyNHandleSetLen_v2(		(Handle *)&prq_h, prq_newalloc * sizeof(prq_vr))))	{		prq_alloc = prq_newalloc;	}	return err;}GLOBALFUNC tMyErr prq_insert_v2(prq_vr v){	tMyErr err;	uimr prq_newn = prq_n + 1;	if (prq_newn > prq_alloc) {		if (noErr != (err = prq_IncreaseMinAlloc_v2(prq_newn))) {			return err;		}	}	prq_floatup(prq_n, v);	prq_n = prq_newn;	return noErr;}