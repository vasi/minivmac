/*	Copyright (C) 2008 Paul Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*/#include "MYMACAPI.i"#if ! IsAnApp#include <Packages.h>#endif#include "COREDEFS.i"#include "POW2UTIL.i"#include "STRUTILS.i"#include "MACENVRN.i"#if IsAnApp#include "MACINITS.i"#endif#include "SAVEDERR.i"#include "FILEUTIL.i"#if 0#include "DEBUGLOG.i"#endif#include "MYMEMORY.i"#if IsAnApp#include "XBUFHAND.i"#include "MYFPMATH.i"#define WantRealInputFile 0#include "PROGRBAR.i"#include "PROGWND1.i"#else#include "TOOLUTIL.i"#include "CMDARGT1.i"#define MyAlertFromCStr DisplayRunErr#define ProgressBar_SetStage(s, n)#endif#include "HEXCONVR.i"#include "STRMOUTT.i"#include "STREAMIN.i"#include "TOKENIZR.i"#include "BINPRGIN.i"#include "BINPRMAP.i"#include "PRIQUEUE.i"#define BitAnd(x, y) (((uimr)(x)) & ((uimr)(y)))/* -- dumbhacks.h -- */#define binmap_kIsCode 2#define binmap_kIsNotCode 3/* -- readfile -- */LOCALFUNC ui4r prgin_readByteAt(uimr i){	prgin_seek(i);	return prgin_readByte();}LOCALFUNC ui4r prgin_readWordAt(uimr i){	prgin_seek(i);	return prgin_readWord();}LOCALFUNC ui5r prgin_readLongAt(uimr i){	prgin_seek(i);	return prgin_readLong();}LOCALPROC get4str(uimr i, StringPtr s){	short y;	PStrCopy(s, (StringPtr)"\p    ");  /* four spaces */	prgin_seek(i);	for (y = 1; y <= 4; ++y) {		s[y] = (char)prgin_readByte();	}}LOCALVAR uimr binmap_cache_rangebottom = 0;LOCALVAR uimr binmap_cache_rangetop = 0;LOCALVAR ui4r binmap_cache_rangekind = 0;LOCALPROC binmap_cache_set(uimr rangebottom, uimr rangetop, ui4r rangekind){	if ((rangekind != binmap_cache_rangekind)		|| (rangebottom > binmap_cache_rangetop)		|| (rangetop < binmap_cache_rangebottom))	{		if (binmap_cache_rangebottom != binmap_cache_rangetop) {			vCheckSysErr(binmap_set_v2(binmap_cache_rangebottom, binmap_cache_rangetop, binmap_cache_rangekind));		}		binmap_cache_rangebottom = rangebottom;		binmap_cache_rangetop = rangetop;		binmap_cache_rangekind = rangekind;	} else {		if (rangebottom < binmap_cache_rangebottom) {			binmap_cache_rangebottom = rangebottom;		}		if (rangetop > binmap_cache_rangetop) {			binmap_cache_rangetop = rangetop;		}	}}LOCALPROC binmap_cache_flush(void){	if (binmap_cache_rangebottom != binmap_cache_rangetop) {		vCheckSysErr(binmap_set_v2(binmap_cache_rangebottom, binmap_cache_rangetop, binmap_cache_rangekind));	}	binmap_cache_rangebottom = 0;	binmap_cache_rangetop = 0;	binmap_cache_rangekind = 0;}LOCALVAR uimr scan_i;LOCALPROC scan_byte(char *s){	/* fprintf(stderr, "B ; \"%s\" &\n", s); */	strmo_writePStr((StringPtr)"\pB ; \"");	strmo_writeCStr(s);	strmo_writePStr((StringPtr)"\p\" &");	strmo_writeReturn();	binmap_cache_set(scan_i, scan_i + 1, binmap_kIsNotCode);	scan_i += 1;}LOCALPROC scan_word(char *s){	/* fprintf(stderr, "W ; \"%s\" &\n", s); */	strmo_writePStr((StringPtr)"\pW ; \"");	strmo_writeCStr(s);	strmo_writePStr((StringPtr)"\p\" &");	strmo_writeReturn();	binmap_cache_set(scan_i, scan_i + 2, binmap_kIsNotCode);	scan_i += 2;}LOCALPROC scan_long(char *s){	/* fprintf(stderr, "L ; \"%s\" &\n", s); */	strmo_writePStr((StringPtr)"\pL ; \"");	strmo_writeCStr(s);	strmo_writePStr((StringPtr)"\p\" &");	strmo_writeReturn();	binmap_cache_set(scan_i, scan_i + 4, binmap_kIsNotCode);	scan_i += 4;}LOCALPROC scan_ostype(char *s){	MyPStr t;	get4str(scan_i, t);	/* fprintf(stderr, "L ; \"%s %P\" &\n", s, t); */	strmo_writePStr((StringPtr)"\pL ; \"");	strmo_writeCStr(s);	strmo_writeSpace();	strmo_writePStr(t);	strmo_writePStr((StringPtr)"\p\" &");	strmo_writeReturn();	binmap_cache_set(scan_i, scan_i + 4, binmap_kIsNotCode);	scan_i += 4;}LOCALPROC strmo_writeDoubleQuote(void){	strmo_writeChar('"');}LOCALPROC scan_other_noncode(char *s, uimr stop){	/* fprintf(stderr, "? ! \"%s\"\n", s); */	strmo_writePStr((StringPtr)"\p? ! \"");	strmo_writeCStr(s);	strmo_writeDoubleQuote();	strmo_writeReturn();	/* fprintf(stderr, ". %X ! \"end of %s\"\n", stop, s); */	strmo_writePStr((StringPtr)"\p. ");	strmo_Uimr2Hex(stop);	strmo_writePStr((StringPtr)"\p ! \"end of ");	strmo_writeCStr(s);	strmo_writeDoubleQuote();	strmo_writeReturn();	binmap_cache_set(scan_i, stop, binmap_kIsNotCode);	scan_i = stop;}LOCALPROC scan_other_maybecode(char *s, uimr stop){	/* fprintf(stderr, "? ! \"%s\"\n", s); */	strmo_writePStr((StringPtr)"\p? ! \"");	strmo_writeCStr(s);	strmo_writeDoubleQuote();	strmo_writeReturn();	/* fprintf(stderr, ". %X ! \"end of %s\"\n", stop, s); */	strmo_writePStr((StringPtr)"\p. ");	strmo_Uimr2Hex(stop);	strmo_writePStr((StringPtr)"\p ! \"end of ");	strmo_writeCStr(s);	strmo_writeDoubleQuote();	strmo_writeReturn();	scan_i = stop;}LOCALPROC write_linecomment(char *s){	/* fprintf(stderr, "! \"%s\"\n", s); */	strmo_writePStr((StringPtr)"\p! \"");	strmo_writeCStr(s);	strmo_writeDoubleQuote();	strmo_writeReturn();}LOCALPROC write_linecmntnewln(char *s){	strmo_writeReturn();	/* fprintf(stderr, "! \"%s\"\n", s); */	strmo_writePStr((StringPtr)"\pS ! \"");	strmo_writeCStr(s);	strmo_writeDoubleQuote();	strmo_writeReturn();}LOCALVAR uimr scan_next;LOCALVAR uimr scan_end;struct scan_svr {	uimr scan_i;	uimr scan_next;	uimr scan_end;};typedef struct scan_svr scan_svr;LOCALPROC scan_start(scan_svr *r, uimr end){	r->scan_next = scan_next;	r->scan_end = scan_end;	scan_next = end;	scan_end = end;}LOCALPROC scan_stop(scan_svr *r){	scan_next = r->scan_next;	scan_end = r->scan_end;}LOCALFUNC blnr scan_is(uimr i){	if (scan_i != i) {		if ((i > scan_i) && (i < scan_next)) {			scan_next = i;		}		return falseblnr;	}	return trueblnr;}LOCALFUNC blnr scan_unused(void){	if (scan_i >= scan_next) {		return falseblnr;	} else {		scan_other_maybecode("Unused area", scan_next);		scan_next = scan_end;		return trueblnr;	}}LOCALPROC scan_to(uimr i){	if (i != scan_i) {		scan_other_maybecode("Unused area", i);	}}LOCALVAR uimr dataddr;LOCALVAR uimr mapaddr;LOCALVAR uimr datsize;LOCALVAR uimr mapsize;LOCALVAR uimr typaddr;LOCALVAR uimr namaddr;LOCALVAR uimr ntpes;LOCALVAR uimr rshdrsz;LOCALVAR uimr rsoffbs;LOCALFUNC blnr processmap(void){	short m;	short n;	uimr refaddr;	ui4r nt;	uimr p;	simr resaddr;	uimr q;	Str255 s;	simr id;	uimr mapend;	uimr datend;	blnr IsOk = falseblnr;	(void) CheckSysErr(ProgressBar_SetStage_v2("Initial Scan", 0));	dataddr = prgin_readLongAt(0);	mapaddr = prgin_readLongAt(4);	datsize = prgin_readLongAt(8);	mapsize = prgin_readLongAt(12);	datend = dataddr + datsize;	mapend = mapaddr + mapsize;#if 0	fprintf(stderr, "dataddr = %X\n", dataddr);	fprintf(stderr, "mapaddr = %X\n", mapaddr);	fprintf(stderr, "datsize = %X\n", datsize);	fprintf(stderr, "mapsize = %X\n", mapsize);	fprintf(stderr, "datend = %X\n", datend);	fprintf(stderr, "mapend = %X\n", mapend);#endif	if (dataddr < prgin_Mx)	if (mapaddr < prgin_Mx)	if (mapsize >= 30)	if ((datend >= dataddr) && (datend <= prgin_Mx))	if ((mapend >= mapaddr) && (mapend <= prgin_Mx))	{		typaddr = mapaddr + prgin_readWordAt(mapaddr + 24);		namaddr = mapaddr + prgin_readWordAt(mapaddr + 26);#if 0		fprintf(stderr, "typaddr = %X\n", typaddr);		fprintf(stderr, "namaddr = %X\n", namaddr);#endif		if (typaddr <= mapend)		if (namaddr <= mapend)		if (typaddr < namaddr)		{			ntpes = prgin_readWordAt(typaddr);			rshdrsz = 4;			rsoffbs = dataddr + 4;			IsOk = trueblnr;		}	}	if (! IsOk) {		uimr resdataddr = prgin_readLongAt(26);		if (resdataddr >= 30)		if (resdataddr < prgin_Mx)		{			mapaddr = resdataddr + 4;			mapsize = prgin_readWordAt(resdataddr + 2);			dataddr = mapaddr + mapsize;			datsize = prgin_Mx - dataddr;			datend = dataddr + datsize;			mapend = mapaddr + mapsize;#if 0			fprintf(stderr, "dataddr = %X\n", dataddr);			fprintf(stderr, "mapaddr = %X\n", mapaddr);			fprintf(stderr, "datsize = %X\n", datsize);			fprintf(stderr, "mapsize = %X\n", mapsize);			fprintf(stderr, "datend = %X\n", datend);			fprintf(stderr, "mapend = %X\n", mapend);#endif			if (dataddr < prgin_Mx)			if (mapaddr < prgin_Mx)			if (mapsize >= 30)			if ((datend >= dataddr) && (datend <= prgin_Mx))			if ((mapend >= mapaddr) && (mapend <= prgin_Mx))			{				typaddr = mapaddr + prgin_readWordAt(mapaddr + 24);				namaddr = mapaddr + prgin_readWordAt(mapaddr + 26);#if 0				fprintf(stderr, "typaddr = %X\n", typaddr);				fprintf(stderr, "namaddr = %X\n", namaddr);#endif				if (typaddr <= mapend)				if (namaddr <= mapend)				if (typaddr < namaddr)				{					ntpes = prgin_readWordAt(typaddr);					rshdrsz = 8;					rsoffbs = 0;					IsOk = trueblnr;				}			}		}	}	if (! IsOk) {		MyAlertFromCStr("I don't recognize the format of the 'bin' file.");	}#if 0	fprintf(stderr, "dataddr = %X\n", dataddr);	fprintf(stderr, "mapaddr = %X\n", mapaddr);	fprintf(stderr, "ntpes = %X\n", ntpes);#endif	for (m = 0; m <= ntpes; ++m) {		p = typaddr + 2 + 8 * m;		get4str(p, s);		nt = prgin_readWordAt(p + 4);		refaddr = typaddr + prgin_readWordAt(p + 6);#if 0		fprintf(stderr, "now doing type %P\n", s);		fprintf(stderr, "nt = %X\n", nt);		fprintf(stderr, "refaddr = %X\n", refaddr);#endif		for (n = 0; n <= nt; ++n) {			q = refaddr + 12 * n;			id = prgin_readWordAt(q);			resaddr = rsoffbs + BitAnd(16777215, prgin_readLongAt(q + 4));#if 0			fprintf(resmapfile, "%P  %X %X\n", s, id, resaddr);			fprintf(stderr, "%P  %X %X\n", s, id, resaddr);#endif#if 0			if (PStrEq(s, (StringPtr)"\pCODE")				&& (id >= 0)				&& (id < maxcodres))			{				segaddr[id] = resaddr;			}#endif		}	}	return IsOk;}LOCALFUNC blnr find_resource_of_type(ps3p t, ui4r id, uimr *x){	/* inefficient. whatever. */	short m;	short n;	uimr p;	uimr q;	Str255 s;	simr refaddr;	ui4r nt;	for (m = 0; m <= ntpes; ++m) {		p = typaddr + 2 + 8 * m;		get4str(p, s);		if (PStrEq(s, t)) {			nt = prgin_readWordAt(p + 4);			refaddr = typaddr + prgin_readWordAt(p + 6);			for (n = 0; n <= nt; ++n) {				q = refaddr + 12 * n;				if (prgin_readWordAt(q) == id) {					*x = rsoffbs + BitAnd(16777215, prgin_readLongAt(q + 4));					return trueblnr;				}			}		}	}	return falseblnr;}LOCALFUNC blnr find_resource_at(uimr addr, ps3p s, ui4r *id, ps3p descr){	/* inefficient. whatever. */	short m;	short n;	simr resaddr;	uimr refaddr;	ui4r nt;	uimr p;	uimr q;	short noff;	ui4r sL;	for (m = 0; m <= ntpes; ++m) {		p = typaddr + 2 + 8 * m;		nt = prgin_readWordAt(p + 4);		refaddr = typaddr + prgin_readWordAt(p + 6);		for (n = 0; n <= nt; ++n) {			q = refaddr + 12 * n;			resaddr = rsoffbs + BitAnd(16777215, prgin_readLongAt(q + 4));			if (resaddr == addr) {				get4str(p, s);				*id = prgin_readWordAt(q);				PStrFromChar(descr, '\'');				PStrAppend(descr, s);				PStrApndChar(descr, '\'');				PStrApndChar(descr, ' ');				PStrApndChar(descr, '$');				PStrApndSimr2Hex(descr, *id);				noff = prgin_readWordAt(q + 2);				if (-1 != noff) {					PStrApndChar(descr, ' ');					PStrApndChar(descr, '\'');					sL = prgin_readByteAt(namaddr + noff);					while (sL > 0) {						PStrApndChar(descr, prgin_readByte());						--sL;					}					PStrApndChar(descr, '\'');				}				return trueblnr;			}		}	}	return falseblnr;}LOCALFUNC blnr scan_one_resource_name(void){	short m;	short n;	short noff;	uimr rfi;	uimr na;	ui4r sL;	ui4r res_id;	uimr refaddr;	ui4r nt;	uimr p;	Str255 s;	for (m = 0; m <= ntpes; ++m) {		p = typaddr + 2 + 8 * m;		refaddr = typaddr + prgin_readWordAt(p + 6);		nt = prgin_readWordAt(p + 4);		rfi = refaddr;		for (n = 0; n <= nt; ++n) {			noff = prgin_readWordAt(rfi + 2);			if (-1 != noff) {				na = namaddr + noff;				if (scan_is(na)) {					res_id = prgin_readWordAt(rfi);					get4str(p, s);					/* fprintf(stderr, "! \"Name of resource type '%P' %d\"\n", s, res_id); */					strmo_writePStr((StringPtr)"\p! \"Name of resource type '");					strmo_writePStr(s);					strmo_writePStr((StringPtr)"\p' ");					strmo_writeNum(res_id);					strmo_writeDoubleQuote();					strmo_writeReturn();					sL = prgin_readByteAt(scan_i);					scan_byte("length");					scan_other_noncode("Name", scan_i + sL);					return trueblnr;				}			}			rfi += 12;		}	}	return falseblnr;}LOCALFUNC blnr scan_resource_map(void){	short m;	short n;	scan_svr r;	uimr refaddr;	ui4r nt;	uimr p;	Str255 s;	if (! scan_is(mapaddr)) {		return falseblnr;	}	write_linecomment("Resource map");	scan_long("reserved for Offset to resource data");	scan_long("reserved for Offset to resource map");	scan_long("reserved for Length of resource data");	scan_long("reserved for Length of resource map");	scan_long("reserved for handle to next resource map");	scan_word("reserved for file reference number");	scan_word("Resource file attributes");	scan_word("Offset to type list");	scan_word("Offset to resource name list");	scan_to(typaddr);	write_linecomment("Type list");	scan_word("Number of resource types - 1");	for (m = 0; m <= ntpes; ++m) {		scan_ostype("Resource type");		scan_word("Number of resources of this type - 1");		scan_word("Offset to reference list");	}	write_linecomment("end of Type list");	write_linecomment("Reference list");	for (m = 0; m <= ntpes; ++m) {		p = typaddr + 2 + 8 * m;		get4str(p, s);		nt = prgin_readWordAt(p + 4);		refaddr = typaddr + prgin_readWordAt(p + 6);		scan_to(refaddr);		/* fprintf(stderr, "! \"Resource type '%P'\"\n", s); */		strmo_writePStr((StringPtr)"\p! \"Resource type '");		strmo_writePStr(s);		strmo_writePStr((StringPtr)"\p'");		strmo_writeDoubleQuote();		strmo_writeReturn();		for (n = 0; n <= nt; ++n) {			scan_word("Resource ID");			scan_word("Offset to name");			scan_long("Attributes + Offset to data block");			scan_long("reserved for handle");		}		/* fprintf(stderr, "! \"end of Resource type '%P'\"\n", s); */		strmo_writePStr((StringPtr)"\p! \"end of Resource type '");		strmo_writePStr(s);		strmo_writePStr((StringPtr)"\p'");		strmo_writeDoubleQuote();		strmo_writeReturn();	}	write_linecomment("end of Reference list");	scan_to(namaddr);	write_linecomment("Resource name list");	scan_start(&r, mapaddr + mapsize);	while (scan_one_resource_name()		|| scan_unused())	{	}	scan_stop(&r);	write_linecomment("end of Resource name list");	write_linecomment("end of Resource map");	return trueblnr;}LOCALFUNC blnr scan_resource_data(void){	uimr L;	uimr resend;	Str255 s;	Str255 descr;	ui4r id;	if (! scan_is(dataddr)) {		return falseblnr;	}	write_linecmntnewln("Resources data");	while (find_resource_at(scan_i + rshdrsz, s, &id, descr)) {		write_linecmntnewln("resource header");		if (4 == rshdrsz) {			L = prgin_readLongAt(scan_i);			scan_long("Length");			resend = scan_i + L;		} else {			L = prgin_readLongAt(scan_i) & 0x00FFFFFF;			resend = scan_i + L;			scan_long("Length");			scan_long("?");		}		strmo_writePStr((StringPtr)"\p! \"resource : ");		strmo_writePStr(descr);		strmo_writeDoubleQuote();		strmo_writeReturn();		if (PStrEq(s, (StringPtr)"\pCODE")) {			if (0 == id) {				simr tabsiz;				simr stopaddr;				ui4r rtofst;				ui4r seg;				uimr sega;				simr segzaddr = scan_i;				scan_long("above A5 size");				scan_long("below A5 size");				tabsiz = prgin_readLongAt(scan_i);				scan_long("jump tab size");				scan_long("table offset");				stopaddr = scan_i + tabsiz;				while (scan_i < stopaddr) {					rtofst = prgin_readWordAt(scan_i);					scan_word("offset into segment");					scan_word("push");					seg = prgin_readWordAt(scan_i);					scan_word("segment");					scan_word("trap");					if (find_resource_of_type((StringPtr)"\pCODE", seg, &sega)) {						uimr jmpaddr = sega + 4 + rtofst;						vCheckSysErr(prq_insert_v2(jmpaddr));						/* fprintf(segmapfile, "%X %X %X %X\n", addr - segzaddr - 18 + tabofst, jmpaddr, seg, rtofst); */					}				}				scan_to(resend);			} else {				scan_word("offset into jump table");				scan_word("number of entries");				scan_other_maybecode("Code", resend);			}		} else if (PStrEq(s, (StringPtr)"\pDRVR")) {			simr resaddr;			ui4r sL;			resaddr = scan_i;			scan_word("flags");			scan_word("number of ticks between periodic actions");			scan_word("desk accessory event mask");			scan_word("menu ID");			vCheckSysErr(prq_insert_v2(resaddr + prgin_readWordAt(scan_i)));			scan_word("offset to open routine");			vCheckSysErr(prq_insert_v2(resaddr + prgin_readWordAt(scan_i)));			scan_word("offset to prime routine");			vCheckSysErr(prq_insert_v2(resaddr + prgin_readWordAt(scan_i)));			scan_word("offset to control routine");			vCheckSysErr(prq_insert_v2(resaddr + prgin_readWordAt(scan_i)));			scan_word("offset to status routine");			vCheckSysErr(prq_insert_v2(resaddr + prgin_readWordAt(scan_i)));			scan_word("offset to close routine");			sL = prgin_readByteAt(scan_i);			scan_byte("length of driver name");			scan_other_noncode("Name", scan_i + sL);		} else if (PStrEq(s, (StringPtr)"\pSERD")			|| PStrEq(s, (StringPtr)"\pMDEF")			|| PStrEq(s, (StringPtr)"\pMBDF")			|| PStrEq(s, (StringPtr)"\pWDEF")			|| PStrEq(s, (StringPtr)"\pCDEF")			|| PStrEq(s, (StringPtr)"\pPACK")			)		{			vCheckSysErr(prq_insert_v2(scan_i));			strmo_writePStr((StringPtr)"\p?");			strmo_writeReturn();		} else if (PStrEq(s, (StringPtr)"\pSIZE")			|| PStrEq(s, (StringPtr)"\pBNDL")			|| PStrEq(s, (StringPtr)"\pFREF")			|| PStrEq(s, (StringPtr)"\pICN#")			|| PStrEq(s, (StringPtr)"\pMENU")			|| PStrEq(s, (StringPtr)"\pDITL")			|| PStrEq(s, (StringPtr)"\pALRT")			|| PStrEq(s, (StringPtr)"\pSTR ")			|| PStrEq(s, (StringPtr)"\pSICN")			|| PStrEq(s, (StringPtr)"\pCURS")			|| PStrEq(s, (StringPtr)"\pFONT")			|| PStrEq(s, (StringPtr)"\pNFNT")			|| PStrEq(s, (StringPtr)"\pics#")			|| PStrEq(s, (StringPtr)"\pics4")			|| PStrEq(s, (StringPtr)"\pics8")			|| PStrEq(s, (StringPtr)"\picl4")			|| PStrEq(s, (StringPtr)"\picl8")			|| PStrEq(s, (StringPtr)"\pcctb")			|| PStrEq(s, (StringPtr)"\pwctb")			|| PStrEq(s, (StringPtr)"\pclut")			|| PStrEq(s, (StringPtr)"\pmitq")			|| PStrEq(s, (StringPtr)"\pgama")			|| PStrEq(s, (StringPtr)"\pKMAP")			|| PStrEq(s, (StringPtr)"\pKCHR")			|| PStrEq(s, (StringPtr)"\pTMPL")			|| PStrEq(s, (StringPtr)"\pPAT#")			|| PStrEq(s, (StringPtr)"\pclut")			|| PStrEq(s, (StringPtr)"\pvers")			|| PStrEq(s, (StringPtr)"\phfdr")			|| PStrEq(s, (StringPtr)"\psnd ")			)		{			strmo_writePStr((StringPtr)"\p?");			strmo_writeReturn();			binmap_cache_set(scan_i, resend, binmap_kIsNotCode);		} else {			scan_other_maybecode("perhaps code data", resend);		}		if (scan_i != resend) {			strmo_writePStr((StringPtr)"\p. ");			strmo_Uimr2Hex(resend);			strmo_writePStr((StringPtr)"\p ");			scan_i = resend;		}		strmo_writePStr((StringPtr)"\p! \"end of resource : ");		strmo_writePStr(descr);		strmo_writeDoubleQuote();		strmo_writeReturn();	}	scan_to(dataddr + datsize);	write_linecmntnewln("end of Resources data");	return falseblnr;}LOCALPROC scan_data(void){	scan_svr r;	(void) CheckSysErr(ProgressBar_SetStage_v2("Creating format file", 0));	if (4 == rshdrsz) {		scan_i = 0;		write_linecomment("Resource header");		scan_long("Offset to resource data");		scan_long("Offset to resource map");		scan_long("Length of resource data");		scan_long("Length of resource map");		scan_other_maybecode("Reserved for system use", 128);		scan_other_maybecode("Available for application data", 256);		write_linecomment("end of Resource header");	} else {		scan_i = mapaddr - 4;		/* fprintf(stderr, ". %X ! \"Resource in ROM\"\n", scan_i); */		strmo_writePStr((StringPtr)"\p. ");		strmo_Uimr2Hex(scan_i);		strmo_writePStr((StringPtr)"\p ! \"Resource in ROM\"");		strmo_writeReturn();		scan_word("?");		scan_word("resource map size");	}	scan_start(&r, prgin_Mx);	while (scan_resource_data()		|| scan_resource_map()		|| scan_unused())	{	}	scan_stop(&r);}LOCALVAR MyDir_R BaseDirR;LOCALPROC WriteEntries(void){	uimr addr;	(void) CheckSysErr(ProgressBar_SetStage_v2("Creating entries file", 0));	if (CheckSysErr(strmo_open_v2(&BaseDirR, (StringPtr)"\pentries"))) {		while (prq_deletemin((uimr *)&addr)) {			strmo_Simr2Hex(addr);			strmo_writeReturn();		}		(void) CheckSysErr(strmo_close_v2());	}}LOCALPROC DoTheCommand(void){	if (CheckSysErr(MyHGetDir_v2(&BaseDirR)))	if (CheckSysErr(prgin_open_v2(&BaseDirR, (StringPtr)"\pbin")))	if (CheckSysErr(binmap_load_v2(&BaseDirR, (StringPtr)"\pbin_map")))	if (processmap())	{		if (CheckSysErr(strmo_open_v2(&BaseDirR, (StringPtr)"\pformat"))) {			scan_data();			(void) CheckSysErr(strmo_close_v2());		}		(void) CheckSysErr(ProgressBar_SetStage_v2("Saving bin_map file", 0));		binmap_cache_flush();		(void) CheckSysErr(binmap_save_v2(&BaseDirR, (StringPtr)"\pbin_map"));		WriteEntries();	}	binmap_dispose();	(void) CheckSysErr(prgin_close_v2());}#if IsAnAppLOCALPROC ProgramZapVars(void){}LOCALPROC ProgramPreInit(void){	OneWindAppPreInit();}LOCALFUNC blnr ProgramInit(void){#ifdef Have_DEBUGLOG	if (CheckSysErr(dbglog_open()))#endif	if (CheckSysErr(MyMemory_Init_v2()))	if (CheckSysErr(OneWindAppInit_v2()))	{		return trueblnr;	}	return falseblnr;}LOCALPROC ProgramUnInit(void){	OneWindAppUnInit();	MyMemory_UnInit();#ifdef Have_DEBUGLOG	(void) dbglog_close();#endif}int main(void){	ProgramZapVars();	ProgramPreInit();	if (ProgramInit()) {		DoTheCommand();	}	ProgramUnInit();	return 0;}#else#include "CMDARGT2.i"#endif