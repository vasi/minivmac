/*	APPLMAIN.c	Copyright (C) 2010 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	APPLication MAIN*/GLOBALPROC ui2r2LoHex(ui3r v, MyCharR *r){	if (v < 10) {		*r = '0' + v;	} else {		*r = 'a' + v - 10;	}}GLOBALPROC ui3r2LoHex(ui3r v, MyCharR *r){	ui2r2LoHex((v     ) & 0x0F, r + 1);	ui2r2LoHex((v >> 4) & 0x0F, r);}GLOBALFUNC blnr EqualBytes(ui3p s1, ui3p s2, uimr n){	register si5r i;	register ui3p p1 = s1;	register ui3p p2 = s2;	for (i = n; --i >= 0; ) {		if (*p1++ != *p2++) {			return falseblnr;		}	}	return trueblnr;}struct md5_read_r{	MyPtr SavepDt;	short src_refNum;	ui5r L;	uimr offset;};typedef struct md5_read_r md5_read_r;#define md5_read_gd() ((md5_read_r *)(pDt))static pascal tMyErr md5_read(MyPtr p, uimr MaxL, uimr *ActualL){	tMyErr err;	uimr Remaining = md5_read_gd()->L - md5_read_gd()->offset;	if (0 == Remaining) {		err = eofErr;	} else {		ui5r n = (Remaining > MaxL) ? MaxL : Remaining;		if (noErr == (err = CheckAbortRequested()))		if (noErr == (err = MyReadBytes_v2(md5_read_gd()->src_refNum, p, n)))		{			*ActualL = n;			md5_read_gd()->offset += n;			ProgressBarVal += n;		}	}	return err;}LOCALVAR MyCharR outs[35];LOCALFUNC tMyErr DoFilter1(short src_refNum){	tMyErr err;	md5_read_r r;	ui3b resblock[16];	MyCharR oldbuff[32];	r.SavepDt = pDt;	pDt = (MyPtr)&r;	r.offset = 0;	r.src_refNum = src_refNum;	if (noErr == (err = MyOpenFileGetEOF_v2(src_refNum, &r.L)))	if (noErr == (err = ProgressBar_SetStage_v2("Checking, type command period to abort", r.L)))	if (noErr == (err = md5_stream(md5_read, resblock)))	{		/* ok */		int i;		for (i = 0; i < 16; ++i) {			ui3r2LoHex(resblock[i], &outs[i * 2]);		}		outs[32] = ' ';		outs[33] = ' ';		outs[34] = 0;		{			Handle h;			long off;			long v;			if (noErr == (err = MyHandleNew_v2(32, &h))) {				v = GetScrap(h, 'TEXT', &off);				if (v < 0) {					err = v;				} else {					if (32 == v) {						MyMoveBytes((MyPtr)*h, oldbuff, v);						outs[33] = EqualBytes(outs, oldbuff, 32)							? '='							: 0xAD; /* "not equal" character */					}				}				DisposeHandle(h);			}		}		if (noErr == (err = ZeroScrap()))		if (noErr == (err = PutScrap(32, 'TEXT', outs)))		{		}		err = noErr; /* ignore any errors from clipboard stuff */	}	pDt = r.SavepDt;	return err;}LOCALFUNC tMyErr DoFilter2(void){	tMyErr err;	MyDir_R src_d;	Str255 src_s;	short src_refNum;	blnr IsOk = falseblnr;	GetInputFile(&src_d, src_s);	if (noErr == (err = MyOpenOldFileRead_v2(&src_d, src_s,		&src_refNum)))	{		err = DoFilter1(src_refNum);		err = CombineErr(err, MyCloseFile_v2(src_refNum));	}	return err;}LOCALPROC ProgramMain(void){	tMyErr err;	vCheckSysErr(ProgressBar_SetStage_v2("Ready for a file to checksum\311", 0));label_1:	WaitForInput();	if (GotInputCur) {		err = DoFilter2();		err = CombineErr(err, ProgressBar_SetStage_v2((noErr == err)			? /* "Done, ready to checksum another\311" */ (char *)outs				: "Aborted, ready to checksum another\311",			0));		if (! CheckSysErr(err)) {			ClearInputA();		}		CloseInputCur();		goto label_1;	}}LOCALPROC ProgramZapVars(void){}LOCALPROC ProgramPreInit(void){	OneWindAppPreInit();}LOCALFUNC blnr ProgramInit(void){	if (CheckSysErr(MyMemory_Init_v2()))	if (CheckSysErr(OneWindAppInit_v2()))	{		return trueblnr;	}	return falseblnr;}LOCALPROC ProgramUnInit(void){	OneWindAppUnInit();	MyMemory_UnInit();}int main(void){	ProgramZapVars();	ProgramPreInit();	if (ProgramInit()) {		ProgramMain();	}	ProgramUnInit();	return 0;}