/*	APPLMAIN.c	Copyright (C) 2007 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	APPLication MAIN*/LOCALVAR blnr CapturingInserts = falseblnr;LOCALVAR ui5b SaveCallBack;LOCALVAR ui4b SaveRawMode;LOCALPROC CapturingInsertsOn(void){	tMyErr err;	if (! CapturingInserts) {		if  (noErr == (err = DiskGetCallBack_v2(&SaveCallBack))) {			if  (noErr == (err = DiskSetCallBack_v2(0))) {				if  (noErr == (err = DiskGetRawMode_v2(&SaveRawMode))) {					if  (noErr == (err = DiskSetRawMode_v2(1))) {						CapturingInserts = trueblnr;					}					if (noErr != err) {						(void) DiskSetRawMode_v2(SaveRawMode);							/* ignore any error, since already got one */					}				}			}			if (noErr != err) {				(void) DiskSetCallBack_v2(SaveCallBack);					/* ignore any error, since already got one */			}		}		(void) CheckSysErr(err);	}}LOCALPROC CapturingInsertsOff(void){	tMyErr err;	if (CapturingInserts) {		err = DiskSetRawMode_v2(SaveRawMode);		err = CombineErr(err, DiskSetCallBack_v2(SaveCallBack));		(void) CheckSysErr(err);		CapturingInserts = falseblnr;	}}LOCALFUNC blnr TryCaptureInsert(tDrive *r){	OSErr err = DiskNextPendingInsert(r);	blnr v = falseblnr;	if (noErr == err) {		v = trueblnr;	} else if (err == (OSErr)0xFFC8) {		/* nothing yet */	} else {		vCheckSysErr(err);	}	return v;}LOCALVAR blnr ReadyToImport = falseblnr;LOCALPROC CheckStateAfterEvents(void){	if (ReadyToImport != (! gBackgroundFlag)) {		ReadyToImport = ! ReadyToImport;		if (ReadyToImport) {			(void) CheckSysErr(ProgressBar_SetStage_v2("Ready to checksum\311", 0));			CapturingInsertsOn();		} else {			CapturingInsertsOff();			(void) CheckSysErr(ProgressBar_SetStage_v2("", 0));		}	}}struct md5_read_r{	MyPtr SavepDt;	tDrive InsertVol;	ui5r L;	uimr offset;};typedef struct md5_read_r md5_read_r;#define md5_read_gd() ((md5_read_r *)(pDt))static pascal tMyErr md5_read(MyPtr p, uimr MaxL, uimr *ActualL){	tMyErr err;	uimr Remaining = md5_read_gd()->L - md5_read_gd()->offset;	if (0 == Remaining) {		err = eofErr;	} else {		ui5r n = (Remaining > MaxL) ? MaxL : Remaining;		if (noErr == (err = CheckAbortRequested()))		if (noErr == (err = DiskRead_v2(p,			md5_read_gd()->InsertVol,			md5_read_gd()->offset, &n)))		{			*ActualL = n;			md5_read_gd()->offset += n;			ProgressBarVal += n;		}	}	return err;}GLOBALPROC ui2r2LoHex(ui3r v, MyCharR *r){	if (v < 10) {		*r = '0' + v;	} else {		*r = 'a' + v - 10;	}}GLOBALPROC ui3r2LoHex(ui3r v, MyCharR *r){	ui2r2LoHex((v     ) & 0x0F, r + 1);	ui2r2LoHex((v >> 4) & 0x0F, r);}GLOBALFUNC blnr EqualBytes(ui3p s1, ui3p s2, uimr n){	register si5r i;	register ui3p p1 = s1;	register ui3p p2 = s2;	for (i = n; --i >= 0; ) {		if (*p1++ != *p2++) {			return falseblnr;		}	}	return trueblnr;}LOCALPROC TryImportHostFile(void){	tMyErr err;	md5_read_r r;	ui3b resblock[16];	tPbuf ClipOut;	MyCharR outs[35];	blnr HaveOld;	ui4r version;	MyCharR oldbuff[32];	ui5r OldL;	r.SavepDt = pDt;	pDt = (MyPtr)&r;	if (TryCaptureInsert(&r.InsertVol)) {		r.offset = 0;		if (noErr == (err = DiskGetSize_v2(r.InsertVol, &r.L)))		if (noErr == (err = ProgressBar_SetStage_v2("Checking, type command period to abort", r.L)))		if (noErr == (err = md5_stream(md5_read, resblock)))		{			/* ok */			int i;			for (i = 0; i < 16; ++i) {				ui3r2LoHex(resblock[i], &outs[i * 2]);			}			HaveOld = falseblnr;			if (noErr == (err = HTCVersion_v2(&version))) {				/* clip extension present */				if (noErr == (err = HTCImport_v2(&ClipOut))) {					if (noErr == (err = PBufGetSize_v2(ClipOut, &OldL)))					if (32 == OldL)					if (noErr == (err = PbufTransfer_v2(oldbuff, ClipOut, 0,						OldL, falseblnr)))					{						HaveOld = trueblnr;					}					(void) PbufDispose_v2(ClipOut);				}				if (noErr == (err = Ptr2Pbuf_v2(outs, 32, &ClipOut)))				if (noErr == (err = HTCExport_v2(ClipOut)))				{				}			}			err = noErr; /* ignore any errors from clipboard stuff */			outs[32] = ' ';			if (! HaveOld) {				outs[33] = ' ';			} else {				outs[33] = EqualBytes(outs, oldbuff, 32)					? '='					: 0xAD; /* "not equal" character */			}			outs[34] = 0;		}		err = CombineErr(err, DiskEject_v2(r.InsertVol));		err = CombineErr(err, ProgressBar_SetStage_v2((noErr == err)			? /* "Done, ready to checksum another\311" */ (char *)outs				: "Aborted, ready to checksum another\311",			0));		if (kMyErrUsrCancel != err) {			(void) CheckSysErr(err);		}	}	pDt = r.SavepDt;}LOCALPROC ProgramMain(void){	while (! ProgramDone) {		UpdateProgressBar();		ReportErrors();		MyDoNextEvents(CapturingInserts ? 5			: 5 * 60 * 60);		CheckStateAfterEvents();		if (CapturingInserts) {			TryImportHostFile();		}	}}LOCALPROC ProgramZapVars(void){}LOCALPROC ProgramPreInit(void){	OneWindAppPreInit();}LOCALFUNC blnr ImportExtnInit(void){	ui4r version;	ui5b features;	blnr IsOk = falseblnr;	if (! (noErr == HaveDiskExtenstion_v2())) {		MyAlertFromCStr("The Mini vMac extension mechanism is not available.");	} else if (! CheckSysErr(DiskVersion_v2(&version))) {	} else if (version < 2) {		MyAlertFromCStr("The Disk Extension version is too old.");	} else if (! CheckSysErr(DiskFeatures_v2(&features))) {	} else if (0 == (features & ((ui5b)1 << kFeatureCmndDisk_RawMode))) {		MyAlertFromCStr("Raw mode access feature is not available.");	} else if (0 == (features & ((ui5b)1 << kFeatureCmndDisk_GetName))) {		MyAlertFromCStr("Get Disk name feature is not available.");	} else {		IsOk = trueblnr;	}	return IsOk;}LOCALFUNC blnr ProgramInit(void){	if (CheckSysErr(MyMemory_Init_v2()))	if (ImportExtnInit())	if (CheckSysErr(OneWindAppInit_v2()))	{		return trueblnr;	}	return falseblnr;}LOCALPROC ProgramUnInit(void){	CapturingInsertsOff();	OneWindAppUnInit();	MyMemory_UnInit();}int main(void){	ProgramZapVars();	ProgramPreInit();	if (ProgramInit()) {		ProgramMain();	}	ProgramUnInit();	return 0;}