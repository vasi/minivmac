/*	APPLMAIN.c	Copyright (C) 2010 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	APPLication MAIN*//*	_PmgrOp ($A085) partial API	from communication with R. Belmont*/LOCALFUNC blnr CheckForPMgr(void){	blnr v = falseblnr;#if 1	if (! OSTrapAvailable(0xA085)) {		MyAlertFromCStr("_PMgrOp is not available.");	} else#endif	{		v = trueblnr;	}	return v;}struct PMgrR {	ui4b Command;	ui4b Length;	MyPtr SendBufferP;	MyPtr ReceiveBufferP;	MyByte WorkArea[4];};typedef struct PMgrR PMgrR;#if PRAGMA_PARAMETER#pragma parameter __D0 PMgrOp(__A0)#endifpascal OSErrPMgrOp(PMgrR* myPB)	= {#if PRAGMA_PARAMETER		0xA085#else		0x205F, /* MOVEA.L    (A7)+,A0 */		0xA085, /* _PMgrOp */		0x3E80  /* MOVE.W     D0,(A7) */#endif	};#define readPmgrRAM  0x00E8struct ReadPmgrRamR {	ui4b Address;	ui3b Length;};typedef struct ReadPmgrRamR ReadPmgrRamR;#define RomBase 0xE000#define RomLength 0x2000#define MaxPMgrTransfer 4	/*		R. Belmont says:		"4 bytes per transfer is probably a safe limit"	*/LOCALFUNC tMyErr ReadPMUROM(Handle RomH){	tMyErr err;	Ptr p = *RomH;	uimr offset = RomBase;	uimr L = RomLength;	HLock(RomH);Label_1:	if (L == 0) {		err = noErr;	} else {		ui5r n = (L > MaxPMgrTransfer) ? MaxPMgrTransfer : L;		if (noErr == (err = CheckAbortRequested())) {#if 0			/*				dummy code - so can develop rest of application				without a machine with a PMU.			*/			uimr t = LMGetTicks();			while (t == LMGetTicks()) {			}			*(ui5b *)p = L;#else			ReadPmgrRamR SendR;			PMgrR r;			SendR.Address = offset;			SendR.Length = n;			r.Command = readPmgrRAM;			r.Length = 3;			r.SendBufferP = (MyPtr)&SendR;			r.ReceiveBufferP = (MyPtr)p;			if (noErr != (err = PMgrOp(&r))) {				MyAlertFromCStr("PMgrOp returned error.");				err = kMyErrReported;			} else#endif			{				L -= n;				p += n;				offset += n;				ProgressBarVal += n;				goto Label_1;			}		}	}	HUnlock(RomH);	return err;}#define MyCreator 'MnvM'#define MyFileType 'ROM!'LOCALFUNC tMyErr WritePMUROM(Handle RomH){	/* adapt code from CopyRoms */	tMyErr err;	ParamBlockRec b;	short VRefNum;	StringPtr MyFileName = ((StringPtr)"\pPMU.ROM");	/*		"use low level calls, since glue for higher level		calls provided with my development environment do not		work on Macintosh 128K." (originally. now just		leave this in, instead of using FILUTIL.i, since		it is already written. Using the low level stuff		directly is more efficient, if less clear.)	*/	b.ioParam.ioCompletion = 0;	b.ioParam.ioNamePtr = 0;	if (noErr == (err = PBGetVolSync(&b))) {		VRefNum = b.ioParam.ioVRefNum;		b.ioParam.ioNamePtr = MyFileName;		b.ioParam.ioVersNum = 0;		err = PBCreateSync(&b);		if (err == dupFNErr) {			if (noErr == PBDeleteSync(&b)) {				err = PBCreateSync(&b);			}		}		if (noErr == err) {			b.ioParam.ioPermssn = fsRdWrPerm;			b.ioParam.ioMisc = 0;			if (noErr == (err = PBOpenSync(&b))) {				HLock(RomH);				b.ioParam.ioBuffer = *RomH;				b.ioParam.ioReqCount = RomLength;				b.ioParam.ioPosMode = fsFromStart;				b.ioParam.ioPosOffset = 0;				err = PBWriteSync(&b);				HUnlock(RomH);				err = CombineErr(err, PBCloseSync(&b));				b.fileParam.ioNamePtr = MyFileName;				b.fileParam.ioVRefNum = VRefNum;				b.fileParam.ioFVersNum = 0;				b.fileParam.ioFDirIndex = 0;				if (noErr == (err = PBGetFInfoSync(&b))) {					b.fileParam.ioFlFndrInfo.fdType = MyFileType;					b.fileParam.ioFlFndrInfo.fdCreator = MyCreator;					err = PBSetFInfoSync(&b);				}			}		}	}	return err;}LOCALPROC ProgramMain(void){	tMyErr err;	Handle RomH;	if (noErr == (err = MyHandleNew_v2(RomLength, &RomH))) {		if (noErr == (err = ProgressBar_SetStage_v2(			"Reading, type command period to abort", RomLength)))		if (noErr == (err = ReadPMUROM(RomH)))		if (noErr == (err = ProgressBar_SetStage_v2(			"Writing", 0)))		{			err = WritePMUROM(RomH);		}		DisposeHandle(RomH);	}	if (kMyErrUsrCancel != err) {		(void) CheckSysErr(err);	}}LOCALPROC ProgramZapVars(void){}LOCALPROC ProgramPreInit(void){	OneWindAppPreInit();}LOCALFUNC blnr ProgramInit(void){	if (CheckSysErr(MyMemory_Init_v2()))	if (CheckForPMgr())	if (CheckSysErr(OneWindAppInit_v2()))	{		return trueblnr;	}	return falseblnr;}LOCALPROC ProgramUnInit(void){	OneWindAppUnInit();	MyMemory_UnInit();}int main(void){	ProgramZapVars();	ProgramPreInit();	if (ProgramInit()) {		ProgramMain();	}	ProgramUnInit();	return 0;}