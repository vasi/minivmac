/*	APPLMAIN.c	Copyright (C) 2010 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	APPLication MAIN*//*	_SlotManager ($A06E) partial API*/struct SpBlock {	long spResult;	Ptr spsPointer;	long spSize;	long spOffsetData;	Ptr spIOFileName;	Ptr spsExecPBlk;	long spParamData;	long spMisc;	long spReserved;	short spIOReserved;	short spRefNum;	short spCategory;	short spCType;	short spDrvrSW;	short spDrvrHW;	SInt8 spTBMask;	SInt8 spSlot;	SInt8 spID;	SInt8 spExtDev;	SInt8 spHwDev;	SInt8 spByteLanes;	SInt8 spFlags;	SInt8 spKey;};typedef struct SpBlock SpBlock;typedef SpBlock *SpBlockPtr;struct SInfoRecord {	Ptr siDirPtr;	short siInitStatusA;	short siInitStatusV;	SInt8 siState;	SInt8 siCPUByteLanes;	SInt8 siTopOfROM;	SInt8 siStatusFlags;	short siTOConst;	SInt8 siReserved[2];	Ptr siROMAddr;	SInt8 siSlot;	SInt8 siPadding[3];};typedef struct SInfoRecord SInfoRecord;typedef SInfoRecord * SInfoRecPtr;struct FHeaderRec {	long fhDirOffset;	long fhLength;	long fhCRC;	SInt8 fhROMRev;	SInt8 fhFormat;	long fhTstPat;	SInt8 fhReserved;	SInt8 fhByteLanes;};typedef struct FHeaderRec FHeaderRec;typedef FHeaderRec *FHeaderRecPtr;#define smEmptySlot (-300)#define smDisabledSlot (-305)#define smBLFieldBad (-309)#define smInitStatVErr (-316)#if PRAGMA_PARAMETER#pragma parameter __D0 SReadInfo(__A0)#endifpascal OSErrSReadInfo(SpBlockPtr spBlkPtr)	= {#if PRAGMA_PARAMETER		0x7010, 0xA06E#else		0x205F, /* MOVEA.L    (A7)+,A0 */		0x7010, /* MoveQ.L    $10, D0 */		0xA06E, /* _SlotManager */		0x3E80  /* MOVE.W     D0,(A7) */#endif	};#if PRAGMA_PARAMETER#pragma parameter __D0 SReadFHeader(__A0)#endifpascal OSErrSReadFHeader(SpBlockPtr spBlkPtr)	= {#if PRAGMA_PARAMETER		0x7013, 0xA06E#else		0x205F, /* MOVEA.L    (A7)+,A0 */		0x7013, /* MoveQ.L    $10, D0 */		0xA06E, /* _SlotManager */		0x3E80  /* MOVE.W     D0,(A7) */#endif	};#if PRAGMA_PARAMETER#pragma parameter __D0 SReadStruct(__A0)#endifpascal OSErrSReadStruct(SpBlockPtr spBlkPtr)	= {#if PRAGMA_PARAMETER		0x7007, 0xA06E#else		0x205F, /* MOVEA.L    (A7)+,A0 */		0x7007, /* MoveQ.L    $10, D0 */		0xA06E, /* _SlotManager */		0x3E80  /* MOVE.W     D0,(A7) */#endif	};#define true32b 1#if PRAGMA_PARAMETER#pragma parameter SwapMMUMode(__A0)#endifpascal voidSwapMMUMode(SInt8 * mode)	= {#if PRAGMA_PARAMETER		0x1010, 0xA05D, 0x1080#else		0x206F, 0004, /* MOVEA.L    $0004(A7),A0 */		0x1010,       /* MOVE.B     (A0),D0 */		0xA05D,       /* _SwapMMUMode */		0x206F, 0004, /* MOVEA.L    $0004(A7),A0 */		0x1080,       /* MOVE.B     D0,(A0) */		0x205F,       /* MOVEA.L    (A7)+,A0 */		0x584F,       /* ADDQ.W     #4,A7 */		0x4ED0        /* JMP        (A0) */#endif	};#if PRAGMA_PARAMETER#pragma parameter __D0 StripAddress(__D0)#endifpascal PtrStripAddress(void * theAddress)	= {#if PRAGMA_PARAMETER		0xA055#else		0x201F, /* MOVE.L     (A7)+,D0 */		0xA055, /* _StripAddress */		0x2E80  /* MOVE.L     D0,(A7) */#endif	};pascal voidFixPC(void)	= {		0x41FA, 0x000A, /* LEA *+$000C, A0 */		0x2008,         /* MOVE.L A0, D0 */		0xA055,         /* _StripAddress */		0x2040,         /* MOVEA.L D0, A0 */		0x4ED0          /* JMP (A0)  */	};LOCALFUNC blnr CheckForSlotMgr(void){	blnr v = falseblnr;#ifdef Have_DEBUGLOG	dbglog_writeln("Enter CheckForSlotMgr");#endif#if 1	if (! OSTrapAvailable(0xA06E)) {		MyAlertFromCStr("Slot Manager is not available.");	} else#endif	{#ifdef Have_DEBUGLOG		dbglog_writeln("have Slot Manager");#endif		v = trueblnr;	}	return v;}#define MyCreator 'MnvM'#define MyFileType 'ROM!'LOCALFUNC tMyErr WriteROM(StringPtr s, Handle RomH, ui5r RomL){	/* adapt code from CopyRoms */	tMyErr err;	ParamBlockRec b;	short VRefNum;	/*		"use low level calls, since glue for higher level		calls provided with my development environment do not		work on Macintosh 128K." (originally. now just		leave this in, instead of using FILUTIL.i, since		it is already written. Using the low level stuff		directly is more efficient, if less clear.)	*/	b.ioParam.ioCompletion = 0;	b.ioParam.ioNamePtr = 0;	if (noErr == (err = PBGetVolSync(&b))) {		VRefNum = b.ioParam.ioVRefNum;		b.ioParam.ioNamePtr = s;		b.ioParam.ioVersNum = 0;		err = PBCreateSync(&b);		if (err == dupFNErr) {			if (noErr == PBDeleteSync(&b)) {				err = PBCreateSync(&b);			}		}		if (noErr == err) {			b.ioParam.ioPermssn = fsRdWrPerm;			b.ioParam.ioMisc = 0;			if (noErr == (err = PBOpenSync(&b))) {				HLock(RomH);				b.ioParam.ioBuffer = *RomH;				b.ioParam.ioReqCount = RomL;				b.ioParam.ioPosMode = fsFromStart;				b.ioParam.ioPosOffset = 0;				err = PBWriteSync(&b);				HUnlock(RomH);				err = CombineErr(err, PBCloseSync(&b));				b.fileParam.ioNamePtr = s;				b.fileParam.ioVRefNum = VRefNum;				b.fileParam.ioFVersNum = 0;				b.fileParam.ioFDirIndex = 0;				if (noErr == (err = PBGetFInfoSync(&b))) {					b.fileParam.ioFlFndrInfo.fdType = MyFileType;					b.fileParam.ioFlFndrInfo.fdCreator = MyCreator;					err = PBSetFInfoSync(&b);				}			}		}	}	return err;}LOCALFUNC tMyErr CopySlotRom(short i, Ptr p, ui5r L){	tMyErr err;	Handle RomH;	SpBlock SpR;	MyPStr s;	if (noErr == (err = MyHandleNew_v2(L, &RomH))) {		HLock(RomH);		{#if 0			/* doesn't work, and doesn't seem to be needed */			SInt8 myMode = true32b;			FixPC();			SwapMMUMode(&myMode);#endif			SpR.spResult = (long)*RomH;			SpR.spsPointer = p;			SpR.spSize = L;			err = SReadStruct(&SpR);#if 0			SwapMMUMode(&myMode);#endif		}		HUnlock(RomH);		if (noErr != err) {#ifdef Have_DEBUGLOG			dbglog_writelnNum("SReadStruct failed", err);#endif		} else {			PStrFromCStr(s, "Slot0.ROM");			s[5] = (i < 10) ? '0' + i : 'A' + i - 10;			err = WriteROM(s, RomH, L);		}		DisposeHandle(RomH);	}	return err;}LOCALPROC ProgramMain(void){	tMyErr err = noErr;	short i;	SpBlock SpR;	FHeaderRec FHR;	if (noErr == (err = ProgressBar_SetStage_v2(		"Checking Slots", 14)))	{		for (i = 1; (i <= 0x0E) && (noErr == err); ++i) {#ifdef Have_DEBUGLOG			dbglog_writelnNum("--- checking slot", i);#endif			ProgressBarVal = (i - 1);			SpR.spResult = (long)&FHR;			SpR.spSlot = i;			if (noErr != (err = SReadFHeader(&SpR))) {				/*					check for non fatal errors					where just skip this slot.				*/				if (smEmptySlot == err) {					err = noErr;#ifdef Have_DEBUGLOG					dbglog_writeln("empty slot");#endif				} else if (smBLFieldBad == err) {					err = noErr;#ifdef Have_DEBUGLOG					dbglog_writeln("smBLFieldBad");#endif				} else if (smDisabledSlot == err) {					err = noErr;#ifdef Have_DEBUGLOG					dbglog_writeln("smDisabledSlot");#endif				} else if (smInitStatVErr == err) {					err = noErr;#ifdef Have_DEBUGLOG					dbglog_writeln("smInitStatVErr");#endif				} else {					/* unknown error, program will abort */#ifdef Have_DEBUGLOG					dbglog_writelnNum("SReadFHeader failed", err);#endif				}			} else {				ui5r nlanes = (FHR.fhByteLanes & 1)					+ ((FHR.fhByteLanes >> 1) & 1)					+ ((FHR.fhByteLanes >> 2) & 1)					+ ((FHR.fhByteLanes >> 3) & 1);				ui5r endvalid = 0xF0FFFFFF					+ 1					+ (((ui5r)i) << 24);				ui5r firstlane =					(FHR.fhByteLanes & 0x01) ? 0					: (FHR.fhByteLanes & 0x02) ? 1					: (FHR.fhByteLanes & 0x04) ? 2					: 3;#if 0 /* FHR.fhLength is not accurate */				ui5r totlongs = (FHR.fhLength + nlanes - 1) / nlanes;#endif				ui5r LengthGuess = CeilPowerOf2(					- (FHR.fhDirOffset | 0xFF000000));				ui5r totlongs = LengthGuess / nlanes;				ui5r beginvalid = endvalid - totlongs * 4 + firstlane;#ifdef Have_DEBUGLOG				dbglog_writelnNum("slot", i);				dbglog_writelnNum("fhDirOffset", FHR.fhDirOffset);				dbglog_writelnNum("fhLength", FHR.fhLength);				dbglog_writelnNum("fhCRC", FHR.fhCRC);				dbglog_writelnNum("fhROMRev", FHR.fhROMRev);				dbglog_writelnNum("fhFormat", FHR.fhFormat);				dbglog_writelnNum("fhTstPat", FHR.fhTstPat);				dbglog_writelnNum("fhByteLanes", FHR.fhByteLanes);				dbglog_writelnNum("nlanes", nlanes);				dbglog_writelnNum("firstlane", firstlane);#if 0				dbglog_writelnNum("endvalid", endvalid);#endif				dbglog_writelnNum("LengthGuess", LengthGuess);				dbglog_writelnNum("beginvalid", beginvalid);#endif				if (noErr == (err = CheckAbortRequested())) {#if 0					err = CopySlotRom(i, (Ptr)beginvalid, FHR.fhLength);#endif					err = CopySlotRom(i, (Ptr)beginvalid, LengthGuess);#ifdef Have_DEBUGLOG					if (noErr == err) {						SInfoRecord SIR;						SpR.spResult = (long)&SIR;						SpR.spSlot = i;						if (noErr != (err = SReadInfo(&SpR))) {							dbglog_writelnNum("SReadInfo failed", err);						} else {							dbglog_writelnNum("siDirPtr",								(long)SIR.siDirPtr);							dbglog_writelnNum("siInitStatusA",								SIR.siInitStatusA);							dbglog_writelnNum("siInitStatusV",								SIR.siInitStatusV);							dbglog_writelnNum("siState", SIR.siState);							dbglog_writelnNum("siCPUByteLanes",								SIR.siCPUByteLanes);							dbglog_writelnNum("siTopOfROM",								SIR.siTopOfROM);							dbglog_writelnNum("siStatusFlags",								SIR.siStatusFlags);							dbglog_writelnNum("siTOConst",								SIR.siTOConst);							dbglog_writelnNum("siROMAddr",								(long)SIR.siROMAddr);							dbglog_writelnNum("siSlot", SIR.siSlot);						}					}#endif				}			}		}	}	if (kMyErrUsrCancel != err) {		(void) CheckSysErr(err);	}}LOCALPROC ProgramZapVars(void){}LOCALPROC ProgramPreInit(void){	OneWindAppPreInit();}LOCALFUNC blnr ProgramInit(void){#ifdef Have_DEBUGLOG	if (CheckSysErr(dbglog_open()))#endif	if (CheckSysErr(MyMemory_Init_v2()))	if (CheckForSlotMgr())	if (CheckSysErr(OneWindAppInit_v2()))	{		return trueblnr;	}	return falseblnr;}LOCALPROC ProgramUnInit(void){	OneWindAppUnInit();	MyMemory_UnInit();#ifdef Have_DEBUGLOG	(void) dbglog_close();#endif}int main(void){	ProgramZapVars();	ProgramPreInit();	if (ProgramInit()) {		ProgramMain();	}	ProgramUnInit();	return 0;}