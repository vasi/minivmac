/*	WRCNFGGL.i	Copyright (C) 2007 Paul C. Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*//*	WRite "CNFGGLob.h"*/LOCALPROC WriteConfigurationWarning(void){	WriteBlankLineToDestFile();	WriteDestFileLn(		"This file is automatically generated by the build system,");	WriteDestFileLn(		"which tries to know what options are valid in what");	WriteDestFileLn(		"combinations. Avoid changing this file manually unless");	WriteDestFileLn(		"you know what you're doing.");}LOCALPROC WriteCommonCNFGGLOBContents(void){	WriteDestFileLn("/*");	++DestFileIndent;		WriteDestFileLn(			"Configuration options used by both platform specific");		WriteDestFileLn(			"and platform independent code.");		WriteConfigurationWarning();	--DestFileIndent;	WriteDestFileLn("*/");	WriteBlankLineToDestFile();	WriteDestFileLn("/* adapt to current compiler/host processor */");	if (cur_ide == gbk_ide_mw8) {		WriteDestFileLn("/* make sure this is correct CNFGGLOB */");		WriteCheckPreDef("__MWERKS__");		switch (gbo_cpufam) {			case gbk_cpufam_68k:				WriteCheckPreDef("__MC68K__");				if (cur_targ == gbk_targ_mfpu) {					WriteCheckPreDef("__MC68881__");				} else {					WriteCheckPreNDef("__MC68881__");				}				break;			case gbk_cpufam_ppc:				WriteCheckPreDef("__POWERPC__");				break;			case gbk_cpufam_x86:				WriteCheckPreDef("__INTEL__");				break;		}	}	WriteBlankLineToDestFile();#if NeedIntFormatInfo	WriteCompCondBool("MostSigByteFirst",		(gbo_cpufam == gbk_cpufam_68k)		|| (gbo_cpufam == gbk_cpufam_ppc));	WriteCompCondBool("LeastSigByteFirst",		(gbo_cpufam == gbk_cpufam_x86)		|| (gbo_cpufam == gbk_cpufam_x64));	WriteCompCondBool("TwosCompSigned",		(gbo_cpufam == gbk_cpufam_68k)		|| (gbo_cpufam == gbk_cpufam_ppc)		|| (gbo_cpufam == gbk_cpufam_x86)		|| (gbo_cpufam == gbk_cpufam_x64));#endif	if ((gbo_cpufam == gbk_cpufam_68k)		|| (gbo_cpufam == gbk_cpufam_ppc))	{		WriteDestFileLn("#define BigEndianUnaligned 1");		WriteDestFileLn("#define LittleEndianUnaligned 0");	} else if ((gbo_cpufam == gbk_cpufam_x86)		|| (gbo_cpufam == gbk_cpufam_x64))	{		WriteDestFileLn("#define BigEndianUnaligned 0");		WriteDestFileLn("#define LittleEndianUnaligned 1");	} else {		WriteDestFileLn("#define BigEndianUnaligned 0");		WriteDestFileLn("#define LittleEndianUnaligned 0");	}	if (gbo_cpufam == gbk_cpufam_68k) {		WriteDestFileLn("#define HaveCPUfamM68K 1");	}	if ((cur_ide == gbk_ide_bgc) || (cur_ide == gbk_ide_xcd)		|| (cur_ide == gbk_ide_snc)		|| (cur_ide == gbk_ide_cyg)		|| (cur_ide == gbk_ide_dkp))	{		WriteDestFileLn("#define MayInline inline");	} else	if (cur_ide == gbk_ide_mw8) {		WriteDestFileLn("#define MayInline __inline__");	} else	if (cur_ide == gbk_ide_msv) {		if (ide_vers >= 6000) {			WriteDestFileLn("#define MayInline __forceinline");		} else {			WriteDestFileLn("#define MayInline __inline");		}	} else	{		WriteDestFileLn("#define MayInline");	}	if ((cur_ide == gbk_ide_bgc) || (cur_ide == gbk_ide_xcd)		|| (cur_ide == gbk_ide_cyg)		|| (cur_ide == gbk_ide_dkp))	{		WriteDestFileLn(			"#define MayNotInline __attribute__((noinline))");	} else	if ((cur_ide == gbk_ide_msv) && (ide_vers >= 7000)) {		WriteDestFileLn("#define MayNotInline __declspec(noinline)");	} else	{		WriteDestFileLn("#define MayNotInline");	}	WriteCompCondBool("SmallGlobals", gbo_cpufam == gbk_cpufam_68k);	if ((cur_ide == gbk_ide_bgc)		|| (cur_ide == gbk_ide_xcd)		|| (cur_ide == gbk_ide_ccc)		|| (cur_ide == gbk_ide_dvc)		|| (cur_ide == gbk_ide_mgw)		|| (cur_ide == gbk_ide_dmc)		|| (cur_ide == gbk_ide_lcc)		|| (cur_ide == gbk_ide_cyg)		|| (cur_ide == gbk_ide_dkp)		)	{		WriteDestFileLn("#define cIncludeUnused 0");	} else {		WriteDestFileLn("#define cIncludeUnused 1");	}	if (cur_ide == gbk_ide_lcc) {		WriteDestFileLn("#define UnusedParam(x)");	} else {		WriteDestFileLn("#define UnusedParam(p) (void) p");	}	if (cur_ide == gbk_ide_msv) {		WriteBlankLineToDestFile();		WriteDestFileLn("/* --- set up compiler options --- */");		WriteBlankLineToDestFile();		WriteDestFileLn("/* ignore integer conversion warnings */");		WriteDestFileLn(			"#pragma warning(disable : 4244 4761 4018 4245 4024 4305)");		WriteBlankLineToDestFile();		WriteDestFileLn("/* ignore unused inline warning */");		WriteDestFileLn("#pragma warning(disable : 4514 4714)");#if 0		WriteBlankLineToDestFile();		WriteDestFileLn("/* ignore type redefinition warning */");		WriteDestFileLn("#pragma warning(disable : 4142)");#endif		WriteBlankLineToDestFile();		WriteDestFileLn(			"/* ignore unary minus operator"			" applied to unsigned type warning */");		WriteDestFileLn("#pragma warning(disable : 4146)");	if ((gbk_mdl_II == cur_mdl) || (gbk_mdl_IIx == cur_mdl)		|| (em_cpu_vers >= 2))	{		/* C4127: conditional expression is constant */		/*			C4701: local variable may have been used without having			been initialized		*/		WriteBlankLineToDestFile();		WriteDestFileLn("/* more warnings */");		WriteDestFileLn("#pragma warning(disable : 4127 4701)");	}#if IgnoreMoreWarnings		WriteBlankLineToDestFile();		WriteDestFileLn("/* ignore unused code warning */");		WriteDestFileLn("#pragma warning(disable : 4505)");		WriteBlankLineToDestFile();		/* C4054: 'type cast' : from function pointer to data pointer */		/* C4055: 'type cast' : from data pointer to function pointer */		/* C4127: conditional expression is constant */		/*			C4701: local variable may have been used without having			been initialized		*/		WriteDestFileLn("/* more warnings */");		WriteDestFileLn(			"#pragma warning(disable : 4054 4055 4127 4701)");#endif	} else if (cur_ide == gbk_ide_plc) {		WriteBlankLineToDestFile();		WriteDestFileLn("#pragma warn(disable: 2135 2137)");	}	if (cur_ide == gbk_ide_mw8) {		if (gbo_dbg != gbk_dbg_on) {			WriteBlankLineToDestFile();			WriteDestFileLn("#ifdef OptForSpeed");			WriteDestFileLn("#pragma optimize_for_size off");			WriteDestFileLn("#endif");		}	}	WriteBlankLineToDestFile();	WriteDestFileLn("/* --- integer types ---- */");	/*		define signed and unsigned integer types		for 8 bits, 16 bits, 32 bits, and so on.		the computer might not have integer types		of a given size. in this case should define		a type of correct size, such as a structure		type, even if the computer can't directly do		integer operations on it. then set		HaveReal?i?b to 0.	*/	/* 8 bits */	/* (ui3b)0 - (ui3b)1 == (ui3b)255 */	WriteBlankLineToDestFile();	WriteDestFileLn("typedef unsigned char ui3b;");	WriteDestFileLn("#define HaveRealui3b 1");	/* sizeof(si3b) == sizeof(ui3b) */	WriteBlankLineToDestFile();	WriteDestFileLn("typedef signed char si3b;");	WriteDestFileLn("#define HaveRealsi3b 1");	/* 16 bits */	/* (ui4b)0 - (ui4b)1 == (ui4b)65535 */	WriteBlankLineToDestFile();	WriteDestFileLn("typedef unsigned short ui4b;");	WriteDestFileLn("#define HaveRealui4b 1");	/* sizeof(si4b) == sizeof(ui4b) */	WriteBlankLineToDestFile();	WriteDestFileLn("typedef short si4b;");	WriteDestFileLn("#define HaveRealsi4b 1");	/* 32 bits */	/* (ui5b)0 - (ui5b)1 == (ui5b)4294967295 */	WriteBlankLineToDestFile();	if (gbo_cpufam == gbk_cpufam_x64) {		WriteDestFileLn("typedef unsigned int ui5b;");	} else {		WriteDestFileLn("typedef unsigned long ui5b;");	}	WriteDestFileLn("#define HaveRealui5b 1");	/* sizeof(si5b) == sizeof(ui5b) */	WriteBlankLineToDestFile();	if (gbo_cpufam == gbk_cpufam_x64) {		WriteDestFileLn("typedef int si5b;");	} else {		WriteDestFileLn("typedef long si5b;");	}	WriteDestFileLn("#define HaveRealsi5b 1");	/* 64 bits */ /* this is mostly for illustration, not used */#if 0	struct ui6b {		ui5b f0;		ui5b f1;	};	typedef struct ui6b ui6b;	struct si6b {		ui5b f0;		si5b f1;	};	typedef struct si6b si6b;#endif	WriteBlankLineToDestFile();	WriteDestFileLn("#define HaveRealui6b 0");	WriteDestFileLn("#define HaveRealsi6b 0");	WriteBlankLineToDestFile();	WriteDestFileLn("/* --- integer representation types ---- */");	/*		for each integer type, define		the most efficient representation		for parameter passing and temporary		variables on the current		computer.	*/	WriteBlankLineToDestFile();#if ModPPCi3rTypes	if (gbo_cpufam == gbk_cpufam_ppc) {		WriteDestFileLn("typedef ui5b ui3r;");		WriteDestFileLn("#define ui3beqr 0");	} else#endif	{		WriteDestFileLn("typedef ui3b ui3r;");		WriteDestFileLn("#define ui3beqr 1");	}	WriteBlankLineToDestFile();#if ModPPCi3rTypes	if (gbo_cpufam == gbk_cpufam_ppc) {		WriteDestFileLn("typedef si5b si3r;");		WriteDestFileLn("#define si3beqr 0");	} else#endif	{		WriteDestFileLn("typedef si3b si3r;");		WriteDestFileLn("#define si3beqr 1");	}	WriteBlankLineToDestFile();	WriteDestFileLn("typedef ui4b ui4r;");	WriteDestFileLn("#define ui4beqr 1");	WriteBlankLineToDestFile();	WriteDestFileLn("typedef si4b si4r;");	WriteDestFileLn("#define si4beqr 1");	WriteBlankLineToDestFile();	WriteDestFileLn("typedef ui5b ui5r;");	WriteDestFileLn("#define ui5beqr 1");	WriteBlankLineToDestFile();	WriteDestFileLn("typedef si5b si5r;");	WriteDestFileLn("#define si5beqr 1");}LOCALPROC Write64bitConfig(void){	WriteBlankLineToDestFile();	if (cur_ide == gbk_ide_msv) {		WriteDestFileLn("typedef signed __int64 si6r;");		WriteDestFileLn("typedef signed __int64 si6b;");		WriteDestFileLn("typedef unsigned __int64 ui6r;");		WriteDestFileLn("typedef unsigned __int64 ui6b;");		WriteDestFileLn("#define LIT64(a) a##Ui64");	} else {		WriteDestFileLn("typedef signed long long si6r;");		WriteDestFileLn("typedef signed long long si6b;");		WriteDestFileLn("typedef unsigned long long ui6r;");		WriteDestFileLn("typedef unsigned long long ui6b;");		WriteDestFileLn("#define LIT64(a) a##ULL");	}}