/*	app.c	Copyright (C) 2009 Paul Pratt	You can redistribute this file and/or modify it under the terms	of version 2 of the GNU General Public License as published by	the Free Software Foundation.  You should have received a copy	of the license along with this file; see the file COPYING.	This file is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	license for more details.*/#define IsAnApp 1#include "MYMACAPI.i"#include "COREDEFS.i"#include "POW2UTIL.i"#include "MACENVRN.i"#include "MACINITS.i"#define SetPortFromWindow(w) SetPort(w)#define My_LMKeys() ((volatile ui5b *)(0x0174))LOCALFUNC blnr InitMacManagers(void){	MyMacHeapInit();	MyMacToolBoxInit();	return trueblnr;}/*--- screen ---*/LOCALVAR RgnHandle GrayRgnSave = NULL;LOCALVAR short mBarHeightSave;LOCALPROC My_HideMenuBar(void){	RgnHandle mBarRgn = NewRgn();	if (mBarRgn != NULL) {		GrayRgnSave = NewRgn();		if (GrayRgnSave != NULL) {			CopyRgn(GetGrayRgn(), GrayRgnSave);			RectRgn(mBarRgn, &qd.screenBits.bounds);			DiffRgn(mBarRgn, GetGrayRgn(), mBarRgn);				/* menu bar rgn, plus corner areas of main screen */			mBarHeightSave = LMGetMBarHeight();			LMSetMBarHeight(0);			UnionRgn(GetGrayRgn(), mBarRgn, GetGrayRgn());			PaintBehind(LMGetWindowList(), mBarRgn);			CalcVisBehind(LMGetWindowList(), mBarRgn);#if 0			controlStripHidden = false;			if (Gestalt(gestaltControlStripVersion, &result) == noErr) {				if (SBIsControlStripVisible()) {					controlStripHidden = true;					SBShowHideControlStrip(false);				}			}#endif		}		DisposeRgn(mBarRgn);	}}LOCALPROC My_ShowMenuBar(void){	if (GrayRgnSave != NULL) {		LMSetMBarHeight(mBarHeightSave);		CopyRgn(GrayRgnSave, GetGrayRgn());		/* PaintBehind(LMGetWindowList(), GrayRgnSave);		CalcVisBehind(LMGetWindowList(), GrayRgnSave); */		DisposeRgn(GrayRgnSave);		DrawMenuBar();		GrayRgnSave = NULL;#if 0		if (controlStripHidden) {			controlStripHidden = falseblnr;			if (Gestalt(gestaltControlStripVersion, &result) == noErr) {				SBShowHideControlStrip(true);			}		}#endif	}}LOCALVAR WindowPtr gMyMainWindow = NULL;LOCALFUNC blnr ReCreateMainWindow(void){	blnr IsOk = falseblnr;	My_HideMenuBar();	gMyMainWindow = NewWindow(0L, &qd.screenBits.bounds,		(ConstStr255Param)"\pTestSync",		true, zoomDocProc, (WindowPtr) -1, true, 0);	if (gMyMainWindow != NULL) {		IsOk = trueblnr;	}	return IsOk;}LOCALFUNC blnr InstallOurMenus(void){	DrawMenuBar();	return trueblnr;}LOCALFUNC blnr InitOSGLU(void){	if (InitMacManagers())	if (InstallOurMenus())#if 0 /* this test doesn't work */	if (0 == (qd.screenBits.rowBytes & 0x8000))		/* abort if color quickdraw */#endif	if (ReCreateMainWindow())	{		return trueblnr;	}	return falseblnr;}LOCALPROC UnInitOSGLU(void){	My_ShowMenuBar();}pascal pUi5x8VecFromConst(ui5p p, ui5r n, ui5r x)	= {		/* 0x225F, */ 0x221F, 0x201F, 0x205F,		0x48E7, 0x0F00, 0x2E01, 0x2C01,		0x2A01, 0x2801, 0x2200, 0xEB89,		0xD1C1, 0x600A, 0x4840, 0x48E0,		0x0F00, 0x48E0, 0x0F00, 0x51C8,		0xFFF6, 0x4840, 0x51C8, 0xFFEE,		0x4CDF, 0x00F0 /* , 0x4ED1 */	};/*			; MOVEA.L    (A7)+, A1			MOVE.L     (A7)+, D1			MOVE.L     (A7)+, D0			MOVEA.L    (A7)+, A0			MOVEM.L    D4-D7, -(A7)			MOVE.L     D1, D7			MOVE.L     D1, D6			MOVE.L     D1, D5			MOVE.L     D1, D4			MOVE.L     D0, D1			LSL.L      #5, D1			ADD.L      D1, A0			BRA.S      @1@3			SWAP       D0@2			MOVEM.L    D4-D7, -(A0)			MOVEM.L    D4-D7, -(A0)@1			DBF        D0, @2			SWAP       D0			DBF        D0, @3			MOVEM.L    (A7)+, D4-D7			; JMP        (A1)*//*{	NuimrForVar i;	for_NuimrTimes(i, n) {		*p++ = x;		*p++ = x;		*p++ = x;		*p++ = x;		*p++ = x;		*p++ = x;		*p++ = x;		*p++ = x;	}}*/LOCALPROC pUi5VecFromConst(ui5p p, uimr n, ui5r x){	NuimrForVar i;	uimr n0 = n & 7;	for_NuimrTimes(i, n0) {		*p++ = x;	}	n >>= 3;	if (n != 0) {		pUi5x8VecFromConst(p, n, x);	}}LOCALPROC pUi4VecFromConst(ui4p p, uimr n, ui4r x){	ui5b L;	if (AndBits((uimr)p, 2) != 0) {		if (n == 0) {			return;		}		*p = x;		p++;		n--;	}	if (IsOdd(n)) {		n--;		p[n] = (ui4b)x;	}	L = (ui5b)((((ui5b)((ui4b)(x))) << 16) | ((ui4b)(x)));	pUi5VecFromConst((ui5p)p, n / 2, L);}LOCALPROC pUi3VecFromConst(ui3p p, uimr n, ui3r x){	ui4b w;	if (IsOdd((uimr)p)) {		if (n == 0) {			return;		}		*p = (ui3b)x;		p++;		n--;	}	if (IsOdd(n)) {		n--;		p[n] = (ui3b)x;	}	w = (ui4b)((((ui4b)((ui3b)(x))) << 8) | ((ui3b)(x)));	pUi4VecFromConst((ui4p)p, n >> 1, w);}int main(void){	ui3b x = 0;	if (InitOSGLU()) {		SetPortFromWindow(gMyMainWindow);		PaintRect(&gMyMainWindow->portRect);		HideCursor();		while (! (			(My_LMKeys()[0] == 0) && (My_LMKeys()[1] == 0)			&& (My_LMKeys()[2] == 0) && (My_LMKeys()[3] == 0)			&& (LMGetMouseButtonState())))		{			/* wait for all keys and mouse and up */		}		do {			long t;			t = LMGetTicks();			while (t == LMGetTicks()) {				/* wait for vertical retrace */			}			t = LMGetTicks();			{				ui5r n = ((ui4r)(qd.screenBits.bounds.bottom - qd.screenBits.bounds.top)					* (ui5r)qd.screenBits.rowBytes);				ui3r v = 1 << (x & 7);				pUi3VecFromConst((ui3p)qd.screenBits.baseAddr, n, v);				if (t != LMGetTicks()) {					long i;					ui5b *p = (ui5b *)qd.screenBits.baseAddr;					for (i = n >> 2; --i >= 0; ) {						*p = ~ *p;						++p;					}				}			}			++x;		} while ( /* wait for key or mouse down */			(My_LMKeys()[0] == 0) && (My_LMKeys()[1] == 0)			&& (My_LMKeys()[2] == 0) && (My_LMKeys()[3] == 0)			&& (LMGetMouseButtonState()));		FlushEvents(everyEvent, 0);		ShowCursor();		PaintRect(&gMyMainWindow->portRect);	}	UnInitOSGLU();	return 0;}